/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/pb/avatar/{name}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Avatar
     * @description Get an avatar by name
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Avatar Name */
          name: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Returns the generated avatar image */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "image/png": string;
          };
        };
        /** @description Invalid request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "image/png": {
              [key: string]: unknown;
            };
          };
        };
        /** @description Internal server error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "image/png": {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/pb/tekton/pipelines": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Tekton Pipelines
     * @description Get all Tekton pipelines
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["v1.Pipeline"][];
          };
        };
        /** @description Bad Request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
        /** @description Internal Server Error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/pb/tekton/pipelines/{name}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Tekton Pipeline
     * @description Get a specific Tekton pipeline
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Pipeline Name */
          name: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["v1.Pipeline"];
          };
        };
        /** @description Bad Request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
        /** @description Internal Server Error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/pb/tekton/pipelines/{name}/runs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Tekton Pipeline Runs
     * @description Get runs for a specific Tekton pipeline
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Pipeline Name */
          name: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["v1.PipelineRun"][];
          };
        };
        /** @description Bad Request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
        /** @description Internal Server Error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    put?: never;
    /**
     * Create Tekton Pipeline Run
     * @description Create a new run for a Tekton pipeline
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Pipeline Name */
          name: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Created */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["v1.PipelineRun"];
          };
        };
        /** @description Bad Request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
        /** @description Internal Server Error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/pb/tekton/pipelines/{name}/runs/{runName}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Tekton Pipeline Run
     * @description Get a specific run for a Tekton pipeline
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Pipeline Name */
          name: string;
          /** @description Run Name */
          runName: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["v1.PipelineRun"];
          };
        };
        /** @description Bad Request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
        /** @description Internal Server Error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    /**
     * Delete Tekton Pipeline Run
     * @description Delete a specific run for a Tekton pipeline
     */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Pipeline Name */
          name: string;
          /** @description Run Name */
          runName: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
        /** @description Bad Request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
        /** @description Internal Server Error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/pb/tekton/pipelines/runs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get All Tekton Pipeline Runs
     * @description Get all runs for all Tekton pipelines
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["v1.PipelineRun"][];
          };
        };
        /** @description Bad Request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
        /** @description Internal Server Error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/pb/tekton/tasks": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Tekton Tasks
     * @description Get all Tekton tasks
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["v1.Task"][];
          };
        };
        /** @description Bad Request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
        /** @description Internal Server Error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/pb/tekton/tasks/{name}/runs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Tekton Task Runs
     * @description Get runs for a specific Tekton task
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Task Name */
          name: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["v1.TaskRun"][];
          };
        };
        /** @description Bad Request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
        /** @description Internal Server Error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/pb/tekton/tasks/{name}/runs/{runName}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Tekton Task Run
     * @description Get a specific run for a Tekton task
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Task Name */
          name: string;
          /** @description Run Name */
          runName: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["v1.TaskRun"];
          };
        };
        /** @description Bad Request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
        /** @description Internal Server Error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    "apis.Condition": {
      /** @description LastTransitionTime is the last time the condition transitioned from one status to another.
       *     We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       *     differences (all other things held constant).
       *     +optional */
      lastTransitionTime?: components["schemas"]["apis.VolatileTime"];
      /** @description A human readable message indicating details about the transition.
       *     +optional */
      message?: string;
      /** @description The reason for the condition's last transition.
       *     +optional */
      reason?: string;
      /** @description Severity with which to treat failures of this type of condition.
       *     When this is not specified, it defaults to Error.
       *     +optional */
      severity?: components["schemas"]["apis.ConditionSeverity"];
      /** @description Status of the condition, one of True, False, Unknown.
       *     +required */
      status?: components["schemas"]["k8s_io_api_core_v1.ConditionStatus"];
      /** @description Type of condition.
       *     +required */
      type?: components["schemas"]["apis.ConditionType"];
    };
    /** @enum {string} */
    "apis.ConditionSeverity": "" | "Warning" | "Info";
    /** @enum {string} */
    "apis.ConditionType": "Ready" | "Succeeded";
    "apis.VolatileTime": {
      inner?: string;
    };
    "config.FeatureFlags": {
      awaitSidecarReadiness?: boolean;
      coschedule?: string;
      disableAffinityAssistant?: boolean;
      disableCredsInit?: boolean;
      disableInlineSpec?: string;
      enableAPIFields?: string;
      enableArtifacts?: boolean;
      enableCELInWhenExpression?: boolean;
      enableConciseResolverSyntax?: boolean;
      enableKeepPodOnCancel?: boolean;
      enableParamEnum?: boolean;
      enableProvenanceInStatus?: boolean;
      enableStepActions?: boolean;
      enableTektonOCIBundles?: boolean;
      enforceNonfalsifiability?: string;
      maxResultSize?: number;
      requireGitSSHSecretKnownHosts?: boolean;
      resultExtractionMethod?: string;
      runningInEnvWithInjectedSidecars?: boolean;
      scopeWhenExpressionsToTask?: boolean;
      sendCloudEventsForRuns?: boolean;
      setSecurityContext?: boolean;
      /** @description VerificationNoMatchPolicy is the feature flag for "trusted-resources-verification-no-match-policy"
       *     VerificationNoMatchPolicy can be set to "ignore", "warn" and "fail" values.
       *     ignore: skip trusted resources verification when no matching verification policies found
       *     warn: skip trusted resources verification when no matching verification policies found and log a warning
       *     fail: fail the taskrun or pipelines run if no matching verification policies found */
      verificationNoMatchPolicy?: string;
    };
    "intstr.IntOrString": {
      intVal?: number;
      strVal?: string;
      type?: components["schemas"]["intstr.Type"];
    };
    /** @enum {integer} */
    "intstr.Type": 0 | 1;
    /** @enum {string} */
    "k8s_io_api_core_v1.ConditionStatus": "True" | "False" | "Unknown";
    "pod.PodTemplate": {
      /** @description If specified, the pod's scheduling constraints
       *     +optional */
      affinity?: components["schemas"]["v1.Affinity"];
      /** @description AutomountServiceAccountToken indicates whether pods running as this
       *     service account should have an API token automatically mounted.
       *     +optional */
      automountServiceAccountToken?: boolean;
      /** @description Specifies the DNS parameters of a pod.
       *     Parameters specified here will be merged to the generated DNS
       *     configuration based on DNSPolicy.
       *     +optional */
      dnsConfig?: components["schemas"]["v1.PodDNSConfig"];
      /** @description Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are
       *     'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig
       *     will be merged with the policy selected with DNSPolicy.
       *     +optional */
      dnsPolicy?: components["schemas"]["v1.DNSPolicy"];
      /** @description EnableServiceLinks indicates whether information about services should be injected into pod's
       *     environment variables, matching the syntax of Docker links.
       *     Optional: Defaults to true.
       *     +optional */
      enableServiceLinks?: boolean;
      /** @description List of environment variables that can be provided to the containers belonging to the pod.
       *     +optional
       *     +patchMergeKey=name
       *     +patchStrategy=merge
       *     +listType=atomic */
      env?: components["schemas"]["v1.EnvVar"][];
      /** @description HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
       *     file if specified. This is only valid for non-hostNetwork pods.
       *     +optional
       *     +listType=atomic */
      hostAliases?: components["schemas"]["v1.HostAlias"][];
      /** @description HostNetwork specifies whether the pod may use the node network namespace
       *     +optional */
      hostNetwork?: boolean;
      /** @description ImagePullSecrets gives the name of the secret used by the pod to pull the image if specified
       *     +optional
       *     +listType=atomic */
      imagePullSecrets?: components["schemas"]["v1.LocalObjectReference"][];
      /** @description NodeSelector is a selector which must be true for the pod to fit on a node.
       *     Selector which must match a node's labels for the pod to be scheduled on that node.
       *     More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
       *     +optional */
      nodeSelector?: {
        [key: string]: string | undefined;
      };
      /** @description If specified, indicates the pod's priority. "system-node-critical" and
       *     "system-cluster-critical" are two special keywords which indicate the
       *     highest priorities with the former being the highest priority. Any other
       *     name must be defined by creating a PriorityClass object with that name.
       *     If not specified, the pod priority will be default or zero if there is no
       *     default.
       *     +optional */
      priorityClassName?: string;
      /** @description RuntimeClassName refers to a RuntimeClass object in the node.k8s.io
       *     group, which should be used to run this pod. If no RuntimeClass resource
       *     matches the named class, the pod will not be run. If unset or empty, the
       *     "legacy" RuntimeClass will be used, which is an implicit class with an
       *     empty definition that uses the default runtime handler.
       *     More info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md
       *     This is a beta feature as of Kubernetes v1.14.
       *     +optional */
      runtimeClassName?: string;
      /** @description SchedulerName specifies the scheduler to be used to dispatch the Pod
       *     +optional */
      schedulerName?: string;
      /** @description SecurityContext holds pod-level security attributes and common container settings.
       *     Optional: Defaults to empty.  See type description for default values of each field.
       *     +optional */
      securityContext?: components["schemas"]["v1.PodSecurityContext"];
      /** @description If specified, the pod's tolerations.
       *     +optional
       *     +listType=atomic */
      tolerations?: components["schemas"]["v1.Toleration"][];
      /** @description TopologySpreadConstraints controls how Pods are spread across your cluster among
       *     failure-domains such as regions, zones, nodes, and other user-defined topology domains.
       *     +optional
       *     +listType=atomic */
      topologySpreadConstraints?: components["schemas"]["v1.TopologySpreadConstraint"][];
      /** @description List of volumes that can be mounted by containers belonging to the pod.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes
       *     +optional
       *     +patchMergeKey=name
       *     +patchStrategy=merge,retainKeys
       *     +listType=atomic */
      volumes?: components["schemas"]["v1.Volume"][];
    };
    "resource.Quantity": {
      /** @enum {string} */
      Format?: "DecimalExponent" | "BinarySI" | "DecimalSI";
    };
    "runtime.RawExtension": Record<string, never>;
    /** @enum {string} */
    "selection.Operator": "!" | "=" | "==" | "in" | "!=" | "notin" | "exists" | "gt" | "lt";
    "v1.AWSElasticBlockStoreVolumeSource": {
      /** @description fsType is the filesystem type of the volume that you want to mount.
       *     Tip: Ensure that the filesystem type is supported by the host operating system.
       *     Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
       *     TODO: how do we prevent errors in the filesystem from compromising the machine
       *     +optional */
      fsType?: string;
      /** @description partition is the partition in the volume that you want to mount.
       *     If omitted, the default is to mount by volume name.
       *     Examples: For volume /dev/sda1, you specify the partition as "1".
       *     Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
       *     +optional */
      partition?: number;
      /** @description readOnly value true will force the readOnly setting in VolumeMounts.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
       *     +optional */
      readOnly?: boolean;
      /** @description volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore */
      volumeID?: string;
    };
    "v1.Affinity": {
      /** @description Describes node affinity scheduling rules for the pod.
       *     +optional */
      nodeAffinity?: components["schemas"]["v1.NodeAffinity"];
      /** @description Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
       *     +optional */
      podAffinity?: components["schemas"]["v1.PodAffinity"];
      /** @description Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
       *     +optional */
      podAntiAffinity?: components["schemas"]["v1.PodAntiAffinity"];
    };
    "v1.AppArmorProfile": {
      /** @description localhostProfile indicates a profile loaded on the node that should be used.
       *     The profile must be preconfigured on the node to work.
       *     Must match the loaded name of the profile.
       *     Must be set if and only if type is "Localhost".
       *     +optional */
      localhostProfile?: string;
      /** @description type indicates which kind of AppArmor profile will be applied.
       *     Valid options are:
       *       Localhost - a profile pre-loaded on the node.
       *       RuntimeDefault - the container runtime's default profile.
       *       Unconfined - no AppArmor enforcement.
       *     +unionDiscriminator */
      type?: components["schemas"]["v1.AppArmorProfileType"];
    };
    /** @enum {string} */
    "v1.AppArmorProfileType": "Unconfined" | "RuntimeDefault" | "Localhost";
    "v1.ArtifactValue": {
      /** @description Algorithm-specific digests for verifying the content (e.g., SHA256) */
      digest?: {
        [key: string]: string | undefined;
      };
      /** @description Location where the artifact value can be retrieved */
      uri?: string;
    };
    /** @enum {string} */
    "v1.AzureDataDiskCachingMode": "None" | "ReadOnly" | "ReadWrite";
    /** @enum {string} */
    "v1.AzureDataDiskKind": "Shared" | "Dedicated" | "Managed";
    "v1.AzureDiskVolumeSource": {
      /** @description cachingMode is the Host Caching mode: None, Read Only, Read Write.
       *     +optional */
      cachingMode?: components["schemas"]["v1.AzureDataDiskCachingMode"];
      /** @description diskName is the Name of the data disk in the blob storage */
      diskName?: string;
      /** @description diskURI is the URI of data disk in the blob storage */
      diskURI?: string;
      /** @description fsType is Filesystem type to mount.
       *     Must be a filesystem type supported by the host operating system.
       *     Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
       *     +optional */
      fsType?: string;
      /** @description kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared */
      kind?: components["schemas"]["v1.AzureDataDiskKind"];
      /** @description readOnly Defaults to false (read/write). ReadOnly here will force
       *     the ReadOnly setting in VolumeMounts.
       *     +optional */
      readOnly?: boolean;
    };
    "v1.AzureFileVolumeSource": {
      /** @description readOnly defaults to false (read/write). ReadOnly here will force
       *     the ReadOnly setting in VolumeMounts.
       *     +optional */
      readOnly?: boolean;
      /** @description secretName is the  name of secret that contains Azure Storage Account Name and Key */
      secretName?: string;
      /** @description shareName is the azure share Name */
      shareName?: string;
    };
    "v1.CSIVolumeSource": {
      /** @description driver is the name of the CSI driver that handles this volume.
       *     Consult with your admin for the correct name as registered in the cluster. */
      driver?: string;
      /** @description fsType to mount. Ex. "ext4", "xfs", "ntfs".
       *     If not provided, the empty value is passed to the associated CSI driver
       *     which will determine the default filesystem to apply.
       *     +optional */
      fsType?: string;
      /** @description nodePublishSecretRef is a reference to the secret object containing
       *     sensitive information to pass to the CSI driver to complete the CSI
       *     NodePublishVolume and NodeUnpublishVolume calls.
       *     This field is optional, and  may be empty if no secret is required. If the
       *     secret object contains more than one secret, all secret references are passed.
       *     +optional */
      nodePublishSecretRef?: components["schemas"]["v1.LocalObjectReference"];
      /** @description readOnly specifies a read-only configuration for the volume.
       *     Defaults to false (read/write).
       *     +optional */
      readOnly?: boolean;
      /** @description volumeAttributes stores driver-specific properties that are passed to the CSI
       *     driver. Consult your driver's documentation for supported values.
       *     +optional */
      volumeAttributes?: {
        [key: string]: string | undefined;
      };
    };
    "v1.Capabilities": {
      /** @description Added capabilities
       *     +optional
       *     +listType=atomic */
      add?: string[];
      /** @description Removed capabilities
       *     +optional
       *     +listType=atomic */
      drop?: string[];
    };
    "v1.CephFSVolumeSource": {
      /** @description monitors is Required: Monitors is a collection of Ceph monitors
       *     More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
       *     +listType=atomic */
      monitors?: string[];
      /** @description path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
       *     +optional */
      path?: string;
      /** @description readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
       *     the ReadOnly setting in VolumeMounts.
       *     More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
       *     +optional */
      readOnly?: boolean;
      /** @description secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
       *     More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
       *     +optional */
      secretFile?: string;
      /** @description secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
       *     More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
       *     +optional */
      secretRef?: components["schemas"]["v1.LocalObjectReference"];
      /** @description user is optional: User is the rados user name, default is admin
       *     More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
       *     +optional */
      user?: string;
    };
    "v1.ChildStatusReference": {
      /** @description +optional */
      apiVersion?: string;
      /** @description DisplayName is a user-facing name of the pipelineTask that may be
       *     used to populate a UI. */
      displayName?: string;
      /** @description +optional */
      kind?: string;
      /** @description Name is the name of the TaskRun or Run this is referencing. */
      name?: string;
      /** @description PipelineTaskName is the name of the PipelineTask this is referencing. */
      pipelineTaskName?: string;
      /** @description WhenExpressions is the list of checks guarding the execution of the PipelineTask
       *     +optional
       *     +listType=atomic */
      whenExpressions?: components["schemas"]["v1.WhenExpression"][];
    };
    "v1.CinderVolumeSource": {
      /** @description fsType is the filesystem type to mount.
       *     Must be a filesystem type supported by the host operating system.
       *     Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
       *     More info: https://examples.k8s.io/mysql-cinder-pd/README.md
       *     +optional */
      fsType?: string;
      /** @description readOnly defaults to false (read/write). ReadOnly here will force
       *     the ReadOnly setting in VolumeMounts.
       *     More info: https://examples.k8s.io/mysql-cinder-pd/README.md
       *     +optional */
      readOnly?: boolean;
      /** @description secretRef is optional: points to a secret object containing parameters used to connect
       *     to OpenStack.
       *     +optional */
      secretRef?: components["schemas"]["v1.LocalObjectReference"];
      /** @description volumeID used to identify the volume in cinder.
       *     More info: https://examples.k8s.io/mysql-cinder-pd/README.md */
      volumeID?: string;
    };
    /** @enum {string} */
    "v1.ClaimResourceStatus":
      | "ControllerResizeInProgress"
      | "ControllerResizeFailed"
      | "NodeResizePending"
      | "NodeResizeInProgress"
      | "NodeResizeFailed";
    "v1.ClusterTrustBundleProjection": {
      /** @description Select all ClusterTrustBundles that match this label selector.  Only has
       *     effect if signerName is set.  Mutually-exclusive with name.  If unset,
       *     interpreted as "match nothing".  If set but empty, interpreted as "match
       *     everything".
       *     +optional */
      labelSelector?: components["schemas"]["v1.LabelSelector"];
      /** @description Select a single ClusterTrustBundle by object name.  Mutually-exclusive
       *     with signerName and labelSelector.
       *     +optional */
      name?: string;
      /** @description If true, don't block pod startup if the referenced ClusterTrustBundle(s)
       *     aren't available.  If using name, then the named ClusterTrustBundle is
       *     allowed not to exist.  If using signerName, then the combination of
       *     signerName and labelSelector is allowed to match zero
       *     ClusterTrustBundles.
       *     +optional */
      optional?: boolean;
      /** @description Relative path from the volume root to write the bundle. */
      path?: string;
      /** @description Select all ClusterTrustBundles that match this signer name.
       *     Mutually-exclusive with name.  The contents of all selected
       *     ClusterTrustBundles will be unified and deduplicated.
       *     +optional */
      signerName?: string;
    };
    "v1.ConfigMapEnvSource": {
      /** @description Name of the referent.
       *     This field is effectively required, but due to backwards compatibility is
       *     allowed to be empty. Instances of this type with an empty value here are
       *     almost certainly wrong.
       *     TODO: Add other useful fields. apiVersion, kind, uid?
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       *     +optional
       *     +default=""
       *     +kubebuilder:default=""
       *     TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896. */
      name?: string;
      /** @description Specify whether the ConfigMap must be defined
       *     +optional */
      optional?: boolean;
    };
    "v1.ConfigMapKeySelector": {
      /** @description The key to select. */
      key?: string;
      /** @description Name of the referent.
       *     This field is effectively required, but due to backwards compatibility is
       *     allowed to be empty. Instances of this type with an empty value here are
       *     almost certainly wrong.
       *     TODO: Add other useful fields. apiVersion, kind, uid?
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       *     +optional
       *     +default=""
       *     +kubebuilder:default=""
       *     TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896. */
      name?: string;
      /** @description Specify whether the ConfigMap or its key must be defined
       *     +optional */
      optional?: boolean;
    };
    "v1.ConfigMapProjection": {
      /** @description items if unspecified, each key-value pair in the Data field of the referenced
       *     ConfigMap will be projected into the volume as a file whose name is the
       *     key and content is the value. If specified, the listed keys will be
       *     projected into the specified paths, and unlisted keys will not be
       *     present. If a key is specified which is not present in the ConfigMap,
       *     the volume setup will error unless it is marked optional. Paths must be
       *     relative and may not contain the '..' path or start with '..'.
       *     +optional
       *     +listType=atomic */
      items?: components["schemas"]["v1.KeyToPath"][];
      /** @description Name of the referent.
       *     This field is effectively required, but due to backwards compatibility is
       *     allowed to be empty. Instances of this type with an empty value here are
       *     almost certainly wrong.
       *     TODO: Add other useful fields. apiVersion, kind, uid?
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       *     +optional
       *     +default=""
       *     +kubebuilder:default=""
       *     TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896. */
      name?: string;
      /** @description optional specify whether the ConfigMap or its keys must be defined
       *     +optional */
      optional?: boolean;
    };
    "v1.ConfigMapVolumeSource": {
      /** @description defaultMode is optional: mode bits used to set permissions on created files by default.
       *     Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       *     YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       *     Defaults to 0644.
       *     Directories within the path are not affected by this setting.
       *     This might be in conflict with other options that affect the file
       *     mode, like fsGroup, and the result can be other mode bits set.
       *     +optional */
      defaultMode?: number;
      /** @description items if unspecified, each key-value pair in the Data field of the referenced
       *     ConfigMap will be projected into the volume as a file whose name is the
       *     key and content is the value. If specified, the listed keys will be
       *     projected into the specified paths, and unlisted keys will not be
       *     present. If a key is specified which is not present in the ConfigMap,
       *     the volume setup will error unless it is marked optional. Paths must be
       *     relative and may not contain the '..' path or start with '..'.
       *     +optional
       *     +listType=atomic */
      items?: components["schemas"]["v1.KeyToPath"][];
      /** @description Name of the referent.
       *     This field is effectively required, but due to backwards compatibility is
       *     allowed to be empty. Instances of this type with an empty value here are
       *     almost certainly wrong.
       *     TODO: Add other useful fields. apiVersion, kind, uid?
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       *     +optional
       *     +default=""
       *     +kubebuilder:default=""
       *     TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896. */
      name?: string;
      /** @description optional specify whether the ConfigMap or its keys must be defined
       *     +optional */
      optional?: boolean;
    };
    "v1.ContainerPort": {
      /** @description Number of port to expose on the pod's IP address.
       *     This must be a valid port number, 0 < x < 65536. */
      containerPort?: number;
      /** @description What host IP to bind the external port to.
       *     +optional */
      hostIP?: string;
      /** @description Number of port to expose on the host.
       *     If specified, this must be a valid port number, 0 < x < 65536.
       *     If HostNetwork is specified, this must match ContainerPort.
       *     Most containers do not need this.
       *     +optional */
      hostPort?: number;
      /** @description If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
       *     named port in a pod must have a unique name. Name for the port that can be
       *     referred to by services.
       *     +optional */
      name?: string;
      /** @description Protocol for port. Must be UDP, TCP, or SCTP.
       *     Defaults to "TCP".
       *     +optional
       *     +default="TCP" */
      protocol?: components["schemas"]["v1.Protocol"];
    };
    "v1.ContainerStateRunning": {
      /** @description Time at which the container was last (re-)started
       *     +optional */
      startedAt?: string;
    };
    "v1.ContainerStateTerminated": {
      /** @description Container's ID in the format '<type>://<container_id>'
       *     +optional */
      containerID?: string;
      /** @description Exit status from the last termination of the container */
      exitCode?: number;
      /** @description Time at which the container last terminated
       *     +optional */
      finishedAt?: string;
      /** @description Message regarding the last termination of the container
       *     +optional */
      message?: string;
      /** @description (brief) reason from the last termination of the container
       *     +optional */
      reason?: string;
      /** @description Signal from the last termination of the container
       *     +optional */
      signal?: number;
      /** @description Time at which previous execution of the container started
       *     +optional */
      startedAt?: string;
    };
    "v1.ContainerStateWaiting": {
      /** @description Message regarding why the container is not yet running.
       *     +optional */
      message?: string;
      /** @description (brief) reason the container is not yet running.
       *     +optional */
      reason?: string;
    };
    /** @enum {string} */
    "v1.DNSPolicy": "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
    "v1.DownwardAPIProjection": {
      /** @description Items is a list of DownwardAPIVolume file
       *     +optional
       *     +listType=atomic */
      items?: components["schemas"]["v1.DownwardAPIVolumeFile"][];
    };
    "v1.DownwardAPIVolumeFile": {
      /** @description Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
       *     +optional */
      fieldRef?: components["schemas"]["v1.ObjectFieldSelector"];
      /** @description Optional: mode bits used to set permissions on this file, must be an octal value
       *     between 0000 and 0777 or a decimal value between 0 and 511.
       *     YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       *     If not specified, the volume defaultMode will be used.
       *     This might be in conflict with other options that affect the file
       *     mode, like fsGroup, and the result can be other mode bits set.
       *     +optional */
      mode?: number;
      /** @description Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..' */
      path?: string;
      /** @description Selects a resource of the container: only resources limits and requests
       *     (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
       *     +optional */
      resourceFieldRef?: components["schemas"]["v1.ResourceFieldSelector"];
    };
    "v1.DownwardAPIVolumeSource": {
      /** @description Optional: mode bits to use on created files by default. Must be a
       *     Optional: mode bits used to set permissions on created files by default.
       *     Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       *     YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       *     Defaults to 0644.
       *     Directories within the path are not affected by this setting.
       *     This might be in conflict with other options that affect the file
       *     mode, like fsGroup, and the result can be other mode bits set.
       *     +optional */
      defaultMode?: number;
      /** @description Items is a list of downward API volume file
       *     +optional
       *     +listType=atomic */
      items?: components["schemas"]["v1.DownwardAPIVolumeFile"][];
    };
    "v1.Duration": {
      /** @enum {integer} */
      "time.Duration"?:
        | -9223372036854776000
        | 9223372036854776000
        | 1
        | 1000
        | 1000000
        | 1000000000
        | 60000000000
        | 3600000000000;
    };
    "v1.EmbeddedTask": {
      /** @description +optional */
      apiVersion?: string;
      /** @description Description is a user-facing description of the task that may be
       *     used to populate a UI.
       *     +optional */
      description?: string;
      /** @description DisplayName is a user-facing name of the task that may be
       *     used to populate a UI.
       *     +optional */
      displayName?: string;
      /** @description +optional */
      kind?: string;
      /** @description +optional */
      metadata?: components["schemas"]["v1.PipelineTaskMetadata"];
      /** @description Params is a list of input parameters required to run the task. Params
       *     must be supplied as inputs in TaskRuns unless they declare a default
       *     value.
       *     +optional
       *     +listType=atomic */
      params?: components["schemas"]["v1.ParamSpec"][];
      /** @description Results are values that this Task can output
       *     +listType=atomic */
      results?: components["schemas"]["v1.TaskResult"][];
      /** @description Sidecars are run alongside the Task's step containers. They begin before
       *     the steps start and end after the steps complete.
       *     +listType=atomic */
      sidecars?: components["schemas"]["v1.Sidecar"][];
      /** @description Spec is a specification of a custom task
       *     +optional */
      spec?: components["schemas"]["runtime.RawExtension"];
      /** @description StepTemplate can be used as the basis for all step containers within the
       *     Task, so that the steps inherit settings on the base container. */
      stepTemplate?: components["schemas"]["v1.StepTemplate"];
      /** @description Steps are the steps of the build; each step is run sequentially with the
       *     source mounted into /workspace.
       *     +listType=atomic */
      steps?: components["schemas"]["v1.Step"][];
      /** @description Volumes is a collection of volumes that are available to mount into the
       *     steps of the build.
       *     +listType=atomic */
      volumes?: components["schemas"]["v1.Volume"][];
      /** @description Workspaces are the volumes that this Task requires.
       *     +listType=atomic */
      workspaces?: components["schemas"]["v1.WorkspaceDeclaration"][];
    };
    "v1.EmptyDirVolumeSource": {
      /** @description medium represents what type of storage medium should back this directory.
       *     The default is "" which means to use the node's default medium.
       *     Must be an empty string (default) or Memory.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       *     +optional */
      medium?: components["schemas"]["v1.StorageMedium"];
      /** @description sizeLimit is the total amount of local storage required for this EmptyDir volume.
       *     The size limit is also applicable for memory medium.
       *     The maximum usage on memory medium EmptyDir would be the minimum value between
       *     the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       *     The default is nil which means that the limit is undefined.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       *     +optional */
      sizeLimit?: components["schemas"]["resource.Quantity"];
    };
    "v1.EnvFromSource": {
      /** @description The ConfigMap to select from
       *     +optional */
      configMapRef?: components["schemas"]["v1.ConfigMapEnvSource"];
      /** @description An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
       *     +optional */
      prefix?: string;
      /** @description The Secret to select from
       *     +optional */
      secretRef?: components["schemas"]["v1.SecretEnvSource"];
    };
    "v1.EnvVar": {
      /** @description Name of the environment variable. Must be a C_IDENTIFIER. */
      name?: string;
      /** @description Variable references $(VAR_NAME) are expanded
       *     using the previously defined environment variables in the container and
       *     any service environment variables. If a variable cannot be resolved,
       *     the reference in the input string will be unchanged. Double $$ are reduced
       *     to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
       *     "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
       *     Escaped references will never be expanded, regardless of whether the variable
       *     exists or not.
       *     Defaults to "".
       *     +optional */
      value?: string;
      /** @description Source for the environment variable's value. Cannot be used if value is not empty.
       *     +optional */
      valueFrom?: components["schemas"]["v1.EnvVarSource"];
    };
    "v1.EnvVarSource": {
      /** @description Selects a key of a ConfigMap.
       *     +optional */
      configMapKeyRef?: components["schemas"]["v1.ConfigMapKeySelector"];
      /** @description Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
       *     spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
       *     +optional */
      fieldRef?: components["schemas"]["v1.ObjectFieldSelector"];
      /** @description Selects a resource of the container: only resources limits and requests
       *     (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
       *     +optional */
      resourceFieldRef?: components["schemas"]["v1.ResourceFieldSelector"];
      /** @description Selects a key of a secret in the pod's namespace
       *     +optional */
      secretKeyRef?: components["schemas"]["v1.SecretKeySelector"];
    };
    "v1.EphemeralVolumeSource": {
      /** @description Will be used to create a stand-alone PVC to provision the volume.
       *     The pod in which this EphemeralVolumeSource is embedded will be the
       *     owner of the PVC, i.e. the PVC will be deleted together with the
       *     pod.  The name of the PVC will be `<pod name>-<volume name>` where
       *     `<volume name>` is the name from the `PodSpec.Volumes` array
       *     entry. Pod validation will reject the pod if the concatenated name
       *     is not valid for a PVC (for example, too long).
       *
       *     An existing PVC with that name that is not owned by the pod
       *     will *not* be used for the pod to avoid using an unrelated
       *     volume by mistake. Starting the pod is then blocked until
       *     the unrelated PVC is removed. If such a pre-created PVC is
       *     meant to be used by the pod, the PVC has to updated with an
       *     owner reference to the pod once the pod exists. Normally
       *     this should not be necessary, but it may be useful when
       *     manually reconstructing a broken cluster.
       *
       *     This field is read-only and no changes will be made by Kubernetes
       *     to the PVC after it has been created.
       *
       *     Required, must not be nil. */
      volumeClaimTemplate?: components["schemas"]["v1.PersistentVolumeClaimTemplate"];
    };
    "v1.ExecAction": {
      /** @description Command is the command line to execute inside the container, the working directory for the
       *     command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
       *     not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
       *     a shell, you need to explicitly call out to that shell.
       *     Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       *     +optional
       *     +listType=atomic */
      command?: string[];
    };
    "v1.FCVolumeSource": {
      /** @description fsType is the filesystem type to mount.
       *     Must be a filesystem type supported by the host operating system.
       *     Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
       *     TODO: how do we prevent errors in the filesystem from compromising the machine
       *     +optional */
      fsType?: string;
      /** @description lun is Optional: FC target lun number
       *     +optional */
      lun?: number;
      /** @description readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
       *     the ReadOnly setting in VolumeMounts.
       *     +optional */
      readOnly?: boolean;
      /** @description targetWWNs is Optional: FC target worldwide names (WWNs)
       *     +optional
       *     +listType=atomic */
      targetWWNs?: string[];
      /** @description wwids Optional: FC volume world wide identifiers (wwids)
       *     Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
       *     +optional
       *     +listType=atomic */
      wwids?: string[];
    };
    "v1.FieldsV1": Record<string, never>;
    "v1.FlexVolumeSource": {
      /** @description driver is the name of the driver to use for this volume. */
      driver?: string;
      /** @description fsType is the filesystem type to mount.
       *     Must be a filesystem type supported by the host operating system.
       *     Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
       *     +optional */
      fsType?: string;
      /** @description options is Optional: this field holds extra command options if any.
       *     +optional */
      options?: {
        [key: string]: string | undefined;
      };
      /** @description readOnly is Optional: defaults to false (read/write). ReadOnly here will force
       *     the ReadOnly setting in VolumeMounts.
       *     +optional */
      readOnly?: boolean;
      /** @description secretRef is Optional: secretRef is reference to the secret object containing
       *     sensitive information to pass to the plugin scripts. This may be
       *     empty if no secret object is specified. If the secret object
       *     contains more than one secret, all secrets are passed to the plugin
       *     scripts.
       *     +optional */
      secretRef?: components["schemas"]["v1.LocalObjectReference"];
    };
    "v1.FlockerVolumeSource": {
      /** @description datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
       *     should be considered as deprecated
       *     +optional */
      datasetName?: string;
      /** @description datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
       *     +optional */
      datasetUUID?: string;
    };
    "v1.GCEPersistentDiskVolumeSource": {
      /** @description fsType is filesystem type of the volume that you want to mount.
       *     Tip: Ensure that the filesystem type is supported by the host operating system.
       *     Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
       *     TODO: how do we prevent errors in the filesystem from compromising the machine
       *     +optional */
      fsType?: string;
      /** @description partition is the partition in the volume that you want to mount.
       *     If omitted, the default is to mount by volume name.
       *     Examples: For volume /dev/sda1, you specify the partition as "1".
       *     Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
       *     +optional */
      partition?: number;
      /** @description pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk */
      pdName?: string;
      /** @description readOnly here will force the ReadOnly setting in VolumeMounts.
       *     Defaults to false.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
       *     +optional */
      readOnly?: boolean;
    };
    "v1.GRPCAction": {
      /** @description Port number of the gRPC service. Number must be in the range 1 to 65535. */
      port?: number;
      /** @description Service is the name of the service to place in the gRPC HealthCheckRequest
       *     (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
       *
       *     If this is not specified, the default behavior is defined by gRPC.
       *     +optional
       *     +default="" */
      service?: string;
    };
    "v1.GitRepoVolumeSource": {
      /** @description directory is the target directory name.
       *     Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
       *     git repository.  Otherwise, if specified, the volume will contain the git repository in
       *     the subdirectory with the given name.
       *     +optional */
      directory?: string;
      /** @description repository is the URL */
      repository?: string;
      /** @description revision is the commit hash for the specified revision.
       *     +optional */
      revision?: string;
    };
    "v1.GlusterfsVolumeSource": {
      /** @description endpoints is the endpoint name that details Glusterfs topology.
       *     More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod */
      endpoints?: string;
      /** @description path is the Glusterfs volume path.
       *     More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod */
      path?: string;
      /** @description readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
       *     Defaults to false.
       *     More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
       *     +optional */
      readOnly?: boolean;
    };
    "v1.HTTPGetAction": {
      /** @description Host name to connect to, defaults to the pod IP. You probably want to set
       *     "Host" in httpHeaders instead.
       *     +optional */
      host?: string;
      /** @description Custom headers to set in the request. HTTP allows repeated headers.
       *     +optional
       *     +listType=atomic */
      httpHeaders?: components["schemas"]["v1.HTTPHeader"][];
      /** @description Path to access on the HTTP server.
       *     +optional */
      path?: string;
      /** @description Name or number of the port to access on the container.
       *     Number must be in the range 1 to 65535.
       *     Name must be an IANA_SVC_NAME. */
      port?: components["schemas"]["intstr.IntOrString"];
      /** @description Scheme to use for connecting to the host.
       *     Defaults to HTTP.
       *     +optional */
      scheme?: components["schemas"]["v1.URIScheme"];
    };
    "v1.HTTPHeader": {
      /** @description The header field name.
       *     This will be canonicalized upon output, so case-variant names will be understood as the same header. */
      name?: string;
      /** @description The header field value */
      value?: string;
    };
    "v1.HostAlias": {
      /** @description Hostnames for the above IP address.
       *     +listType=atomic */
      hostnames?: string[];
      /** @description IP address of the host file entry.
       *     +required */
      ip?: string;
    };
    /** @enum {string} */
    "v1.HostPathType":
      | ""
      | "DirectoryOrCreate"
      | "Directory"
      | "FileOrCreate"
      | "File"
      | "Socket"
      | "CharDevice"
      | "BlockDevice";
    "v1.HostPathVolumeSource": {
      /** @description path of the directory on the host.
       *     If the path is a symlink, it will follow the link to the real path.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath */
      path?: string;
      /** @description type for HostPath Volume
       *     Defaults to ""
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
       *     +optional */
      type?: components["schemas"]["v1.HostPathType"];
    };
    "v1.ISCSIVolumeSource": {
      /** @description chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
       *     +optional */
      chapAuthDiscovery?: boolean;
      /** @description chapAuthSession defines whether support iSCSI Session CHAP authentication
       *     +optional */
      chapAuthSession?: boolean;
      /** @description fsType is the filesystem type of the volume that you want to mount.
       *     Tip: Ensure that the filesystem type is supported by the host operating system.
       *     Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
       *     TODO: how do we prevent errors in the filesystem from compromising the machine
       *     +optional */
      fsType?: string;
      /** @description initiatorName is the custom iSCSI Initiator Name.
       *     If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
       *     <target portal>:<volume name> will be created for the connection.
       *     +optional */
      initiatorName?: string;
      /** @description iqn is the target iSCSI Qualified Name. */
      iqn?: string;
      /** @description iscsiInterface is the interface Name that uses an iSCSI transport.
       *     Defaults to 'default' (tcp).
       *     +optional */
      iscsiInterface?: string;
      /** @description lun represents iSCSI Target Lun number. */
      lun?: number;
      /** @description portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
       *     is other than default (typically TCP ports 860 and 3260).
       *     +optional
       *     +listType=atomic */
      portals?: string[];
      /** @description readOnly here will force the ReadOnly setting in VolumeMounts.
       *     Defaults to false.
       *     +optional */
      readOnly?: boolean;
      /** @description secretRef is the CHAP Secret for iSCSI target and initiator authentication
       *     +optional */
      secretRef?: components["schemas"]["v1.LocalObjectReference"];
      /** @description targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
       *     is other than default (typically TCP ports 860 and 3260). */
      targetPortal?: string;
    };
    "v1.IncludeParams": {
      /** @description Name the specified combination */
      name?: string;
      /** @description Params takes only `Parameters` of type `"string"`
       *     The names of the `params` must match the names of the `params` in the underlying `Task`
       *     +listType=atomic */
      params?: components["schemas"]["v1.Param"][];
    };
    "v1.KeyToPath": {
      /** @description key is the key to project. */
      key?: string;
      /** @description mode is Optional: mode bits used to set permissions on this file.
       *     Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       *     YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       *     If not specified, the volume defaultMode will be used.
       *     This might be in conflict with other options that affect the file
       *     mode, like fsGroup, and the result can be other mode bits set.
       *     +optional */
      mode?: number;
      /** @description path is the relative path of the file to map the key to.
       *     May not be an absolute path.
       *     May not contain the path element '..'.
       *     May not start with the string '..'. */
      path?: string;
    };
    "v1.LabelSelector": {
      /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed.
       *     +optional
       *     +listType=atomic */
      matchExpressions?: components["schemas"]["v1.LabelSelectorRequirement"][];
      /** @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
       *     map is equivalent to an element of matchExpressions, whose key field is "key", the
       *     operator is "In", and the values array contains only "value". The requirements are ANDed.
       *     +optional */
      matchLabels?: {
        [key: string]: string | undefined;
      };
    };
    /** @enum {string} */
    "v1.LabelSelectorOperator": "In" | "NotIn" | "Exists" | "DoesNotExist";
    "v1.LabelSelectorRequirement": {
      /** @description key is the label key that the selector applies to. */
      key?: string;
      /** @description operator represents a key's relationship to a set of values.
       *     Valid operators are In, NotIn, Exists and DoesNotExist. */
      operator?: components["schemas"]["v1.LabelSelectorOperator"];
      /** @description values is an array of string values. If the operator is In or NotIn,
       *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
       *     the values array must be empty. This array is replaced during a strategic
       *     merge patch.
       *     +optional
       *     +listType=atomic */
      values?: string[];
    };
    "v1.Lifecycle": {
      /** @description PostStart is called immediately after a container is created. If the handler fails,
       *     the container is terminated and restarted according to its restart policy.
       *     Other management of the container blocks until the hook completes.
       *     More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
       *     +optional */
      postStart?: components["schemas"]["v1.LifecycleHandler"];
      /** @description PreStop is called immediately before a container is terminated due to an
       *     API request or management event such as liveness/startup probe failure,
       *     preemption, resource contention, etc. The handler is not called if the
       *     container crashes or exits. The Pod's termination grace period countdown begins before the
       *     PreStop hook is executed. Regardless of the outcome of the handler, the
       *     container will eventually terminate within the Pod's termination grace
       *     period (unless delayed by finalizers). Other management of the container blocks until the hook completes
       *     or until the termination grace period is reached.
       *     More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
       *     +optional */
      preStop?: components["schemas"]["v1.LifecycleHandler"];
    };
    "v1.LifecycleHandler": {
      /** @description Exec specifies the action to take.
       *     +optional */
      exec?: components["schemas"]["v1.ExecAction"];
      /** @description HTTPGet specifies the http request to perform.
       *     +optional */
      httpGet?: components["schemas"]["v1.HTTPGetAction"];
      /** @description Sleep represents the duration that the container should sleep before being terminated.
       *     +featureGate=PodLifecycleSleepAction
       *     +optional */
      sleep?: components["schemas"]["v1.SleepAction"];
      /** @description Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
       *     for the backward compatibility. There are no validation of this field and
       *     lifecycle hooks will fail in runtime when tcp handler is specified.
       *     +optional */
      tcpSocket?: components["schemas"]["v1.TCPSocketAction"];
    };
    "v1.LocalObjectReference": {
      /** @description Name of the referent.
       *     This field is effectively required, but due to backwards compatibility is
       *     allowed to be empty. Instances of this type with an empty value here are
       *     almost certainly wrong.
       *     TODO: Add other useful fields. apiVersion, kind, uid?
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       *     +optional
       *     +default=""
       *     +kubebuilder:default=""
       *     TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896. */
      name?: string;
    };
    "v1.ManagedFieldsEntry": {
      /** @description APIVersion defines the version of this resource that this field set
       *     applies to. The format is "group/version" just like the top-level
       *     APIVersion field. It is necessary to track the version of a field
       *     set because it cannot be automatically converted. */
      apiVersion?: string;
      /** @description FieldsType is the discriminator for the different fields format and version.
       *     There is currently only one possible value: "FieldsV1" */
      fieldsType?: string;
      /** @description FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
       *     +optional */
      fieldsV1?: components["schemas"]["v1.FieldsV1"];
      /** @description Manager is an identifier of the workflow managing these fields. */
      manager?: string;
      /** @description Operation is the type of operation which lead to this ManagedFieldsEntry being created.
       *     The only valid values for this field are 'Apply' and 'Update'. */
      operation?: components["schemas"]["v1.ManagedFieldsOperationType"];
      /** @description Subresource is the name of the subresource used to update that object, or
       *     empty string if the object was updated through the main resource. The
       *     value of this field is used to distinguish between managers, even if they
       *     share the same name. For example, a status update will be distinct from a
       *     regular update using the same manager name.
       *     Note that the APIVersion field is not related to the Subresource field and
       *     it always corresponds to the version of the main resource. */
      subresource?: string;
      /** @description Time is the timestamp of when the ManagedFields entry was added. The
       *     timestamp will also be updated if a field is added, the manager
       *     changes any of the owned fields value or removes a field. The
       *     timestamp does not update when a field is removed from the entry
       *     because another manager took it over.
       *     +optional */
      time?: string;
    };
    /** @enum {string} */
    "v1.ManagedFieldsOperationType": "Apply" | "Update";
    "v1.Matrix": {
      /** @description Include is a list of IncludeParams which allows passing in specific combinations of Parameters into the Matrix.
       *     +optional
       *     +listType=atomic */
      include?: components["schemas"]["v1.IncludeParams"][];
      /** @description Params is a list of parameters used to fan out the pipelineTask
       *     Params takes only `Parameters` of type `"array"`
       *     Each array element is supplied to the `PipelineTask` by substituting `params` of type `"string"` in the underlying `Task`.
       *     The names of the `params` in the `Matrix` must match the names of the `params` in the underlying `Task` that they will be substituting.
       *     +listType=atomic */
      params?: components["schemas"]["v1.Param"][];
    };
    "v1.ModifyVolumeStatus": {
      /** @description status is the status of the ControllerModifyVolume operation. It can be in any of following states:
       *      - Pending
       *        Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
       *        the specified VolumeAttributesClass not existing.
       *      - InProgress
       *        InProgress indicates that the volume is being modified.
       *      - Infeasible
       *       Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
       *     	  resolve the error, a valid VolumeAttributesClass needs to be specified.
       *     Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately. */
      status?: components["schemas"]["v1.PersistentVolumeClaimModifyVolumeStatus"];
      /** @description targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled */
      targetVolumeAttributesClassName?: string;
    };
    /** @enum {string} */
    "v1.MountPropagationMode": "None" | "HostToContainer" | "Bidirectional";
    "v1.NFSVolumeSource": {
      /** @description path that is exported by the NFS server.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs */
      path?: string;
      /** @description readOnly here will force the NFS export to be mounted with read-only permissions.
       *     Defaults to false.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
       *     +optional */
      readOnly?: boolean;
      /** @description server is the hostname or IP address of the NFS server.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs */
      server?: string;
    };
    "v1.NodeAffinity": {
      /** @description The scheduler will prefer to schedule pods to nodes that satisfy
       *     the affinity expressions specified by this field, but it may choose
       *     a node that violates one or more of the expressions. The node that is
       *     most preferred is the one with the greatest sum of weights, i.e.
       *     for each node that meets all of the scheduling requirements (resource
       *     request, requiredDuringScheduling affinity expressions, etc.),
       *     compute a sum by iterating through the elements of this field and adding
       *     "weight" to the sum if the node matches the corresponding matchExpressions; the
       *     node(s) with the highest sum are the most preferred.
       *     +optional
       *     +listType=atomic */
      preferredDuringSchedulingIgnoredDuringExecution?: components["schemas"]["v1.PreferredSchedulingTerm"][];
      /** @description If the affinity requirements specified by this field are not met at
       *     scheduling time, the pod will not be scheduled onto the node.
       *     If the affinity requirements specified by this field cease to be met
       *     at some point during pod execution (e.g. due to an update), the system
       *     may or may not try to eventually evict the pod from its node.
       *     +optional */
      requiredDuringSchedulingIgnoredDuringExecution?: components["schemas"]["v1.NodeSelector"];
    };
    /** @enum {string} */
    "v1.NodeInclusionPolicy": "Ignore" | "Honor";
    "v1.NodeSelector": {
      /** @description Required. A list of node selector terms. The terms are ORed.
       *     +listType=atomic */
      nodeSelectorTerms?: components["schemas"]["v1.NodeSelectorTerm"][];
    };
    /** @enum {string} */
    "v1.NodeSelectorOperator": "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
    "v1.NodeSelectorRequirement": {
      /** @description The label key that the selector applies to. */
      key?: string;
      /** @description Represents a key's relationship to a set of values.
       *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt. */
      operator?: components["schemas"]["v1.NodeSelectorOperator"];
      /** @description An array of string values. If the operator is In or NotIn,
       *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
       *     the values array must be empty. If the operator is Gt or Lt, the values
       *     array must have a single element, which will be interpreted as an integer.
       *     This array is replaced during a strategic merge patch.
       *     +optional
       *     +listType=atomic */
      values?: string[];
    };
    "v1.NodeSelectorTerm": {
      /** @description A list of node selector requirements by node's labels.
       *     +optional
       *     +listType=atomic */
      matchExpressions?: components["schemas"]["v1.NodeSelectorRequirement"][];
      /** @description A list of node selector requirements by node's fields.
       *     +optional
       *     +listType=atomic */
      matchFields?: components["schemas"]["v1.NodeSelectorRequirement"][];
    };
    "v1.ObjectFieldSelector": {
      /** @description Version of the schema the FieldPath is written in terms of, defaults to "v1".
       *     +optional */
      apiVersion?: string;
      /** @description Path of the field to select in the specified API version. */
      fieldPath?: string;
    };
    "v1.ObjectMeta": {
      /** @description Annotations is an unstructured key value map stored with a resource that may be
       *     set by external tools to store and retrieve arbitrary metadata. They are not
       *     queryable and should be preserved when modifying objects.
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
       *     +optional */
      annotations?: {
        [key: string]: string | undefined;
      };
      /** @description CreationTimestamp is a timestamp representing the server time when this object was
       *     created. It is not guaranteed to be set in happens-before order across separate operations.
       *     Clients may not set this value. It is represented in RFC3339 form and is in UTC.
       *
       *     Populated by the system.
       *     Read-only.
       *     Null for lists.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       *     +optional */
      creationTimestamp?: string;
      /** @description Number of seconds allowed for this object to gracefully terminate before
       *     it will be removed from the system. Only set when deletionTimestamp is also set.
       *     May only be shortened.
       *     Read-only.
       *     +optional */
      deletionGracePeriodSeconds?: number;
      /** @description DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
       *     field is set by the server when a graceful deletion is requested by the user, and is not
       *     directly settable by a client. The resource is expected to be deleted (no longer visible
       *     from resource lists, and not reachable by name) after the time in this field, once the
       *     finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
       *     Once the deletionTimestamp is set, this value may not be unset or be set further into the
       *     future, although it may be shortened or the resource may be deleted prior to this time.
       *     For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
       *     by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
       *     the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
       *     remove the pod from the API. In the presence of network partitions, this object may still
       *     exist after this timestamp, until an administrator or automated process can determine the
       *     resource is fully terminated.
       *     If not set, graceful deletion of the object has not been requested.
       *
       *     Populated by the system when a graceful deletion is requested.
       *     Read-only.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       *     +optional */
      deletionTimestamp?: string;
      /** @description Must be empty before the object is deleted from the registry. Each entry
       *     is an identifier for the responsible component that will remove the entry
       *     from the list. If the deletionTimestamp of the object is non-nil, entries
       *     in this list can only be removed.
       *     Finalizers may be processed and removed in any order.  Order is NOT enforced
       *     because it introduces significant risk of stuck finalizers.
       *     finalizers is a shared field, any actor with permission can reorder it.
       *     If the finalizer list is processed in order, then this can lead to a situation
       *     in which the component responsible for the first finalizer in the list is
       *     waiting for a signal (field value, external system, or other) produced by a
       *     component responsible for a finalizer later in the list, resulting in a deadlock.
       *     Without enforced ordering finalizers are free to order amongst themselves and
       *     are not vulnerable to ordering changes in the list.
       *     +optional
       *     +patchStrategy=merge
       *     +listType=set */
      finalizers?: string[];
      /** @description GenerateName is an optional prefix, used by the server, to generate a unique
       *     name ONLY IF the Name field has not been provided.
       *     If this field is used, the name returned to the client will be different
       *     than the name passed. This value will also be combined with a unique suffix.
       *     The provided value has the same validation rules as the Name field,
       *     and may be truncated by the length of the suffix required to make the value
       *     unique on the server.
       *
       *     If this field is specified and the generated name exists, the server will return a 409.
       *
       *     Applied only if Name is not specified.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
       *     +optional */
      generateName?: string;
      /** @description A sequence number representing a specific generation of the desired state.
       *     Populated by the system. Read-only.
       *     +optional */
      generation?: number;
      /** @description Map of string keys and values that can be used to organize and categorize
       *     (scope and select) objects. May match selectors of replication controllers
       *     and services.
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       *     +optional */
      labels?: {
        [key: string]: string | undefined;
      };
      /** @description ManagedFields maps workflow-id and version to the set of fields
       *     that are managed by that workflow. This is mostly for internal
       *     housekeeping, and users typically shouldn't need to set or
       *     understand this field. A workflow can be the user's name, a
       *     controller's name, or the name of a specific apply path like
       *     "ci-cd". The set of fields is always in the version that the
       *     workflow used when modifying the object.
       *
       *     +optional
       *     +listType=atomic */
      managedFields?: components["schemas"]["v1.ManagedFieldsEntry"][];
      /** @description Name must be unique within a namespace. Is required when creating resources, although
       *     some resources may allow a client to request the generation of an appropriate name
       *     automatically. Name is primarily intended for creation idempotence and configuration
       *     definition.
       *     Cannot be updated.
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
       *     +optional */
      name?: string;
      /** @description Namespace defines the space within which each name must be unique. An empty namespace is
       *     equivalent to the "default" namespace, but "default" is the canonical representation.
       *     Not all objects are required to be scoped to a namespace - the value of this field for
       *     those objects will be empty.
       *
       *     Must be a DNS_LABEL.
       *     Cannot be updated.
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
       *     +optional */
      namespace?: string;
      /** @description List of objects depended by this object. If ALL objects in the list have
       *     been deleted, this object will be garbage collected. If this object is managed by a controller,
       *     then an entry in this list will point to this controller, with the controller field set to true.
       *     There cannot be more than one managing controller.
       *     +optional
       *     +patchMergeKey=uid
       *     +patchStrategy=merge
       *     +listType=map
       *     +listMapKey=uid */
      ownerReferences?: components["schemas"]["v1.OwnerReference"][];
      /** @description An opaque value that represents the internal version of this object that can
       *     be used by clients to determine when objects have changed. May be used for optimistic
       *     concurrency, change detection, and the watch operation on a resource or set of resources.
       *     Clients must treat these values as opaque and passed unmodified back to the server.
       *     They may only be valid for a particular resource or set of resources.
       *
       *     Populated by the system.
       *     Read-only.
       *     Value must be treated as opaque by clients and .
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       *     +optional */
      resourceVersion?: string;
      /** @description Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
       *     +optional */
      selfLink?: string;
      /** @description UID is the unique in time and space value for this object. It is typically generated by
       *     the server on successful creation of a resource and is not allowed to change on PUT
       *     operations.
       *
       *     Populated by the system.
       *     Read-only.
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       *     +optional */
      uid?: string;
    };
    /** @enum {string} */
    "v1.OnErrorType": "stopAndFail" | "continue";
    "v1.OwnerReference": {
      /** @description API version of the referent. */
      apiVersion?: string;
      /** @description If true, AND if the owner has the "foregroundDeletion" finalizer, then
       *     the owner cannot be deleted from the key-value store until this
       *     reference is removed.
       *     See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
       *     for how the garbage collector interacts with this field and enforces the foreground deletion.
       *     Defaults to false.
       *     To set this field, a user needs "delete" permission of the owner,
       *     otherwise 422 (Unprocessable Entity) will be returned.
       *     +optional */
      blockOwnerDeletion?: boolean;
      /** @description If true, this reference points to the managing controller.
       *     +optional */
      controller?: boolean;
      /** @description Kind of the referent.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
      kind?: string;
      /** @description Name of the referent.
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names */
      name?: string;
      /** @description UID of the referent.
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids */
      uid?: string;
    };
    "v1.Param": {
      name?: string;
      value?: components["schemas"]["v1.ParamValue"];
    };
    "v1.ParamSpec": {
      /** @description Default is the value a parameter takes if no input value is supplied. If
       *     default is set, a Task may be executed without a supplied value for the
       *     parameter.
       *     +optional */
      default?: components["schemas"]["v1.ParamValue"];
      /** @description Description is a user-facing description of the parameter that may be
       *     used to populate a UI.
       *     +optional */
      description?: string;
      /** @description Enum declares a set of allowed param input values for tasks/pipelines that can be validated.
       *     If Enum is not set, no input validation is performed for the param.
       *     +optional */
      enum?: string[];
      /** @description Name declares the name by which a parameter is referenced. */
      name?: string;
      /** @description Properties is the JSON Schema properties to support key-value pairs parameter.
       *     +optional */
      properties?: {
        [key: string]: components["schemas"]["v1.PropertySpec"] | undefined;
      };
      /** @description Type is the user-specified type of the parameter. The possible types
       *     are currently "string", "array" and "object", and "string" is the default.
       *     +optional */
      type?: components["schemas"]["v1.ParamType"];
    };
    /** @enum {string} */
    "v1.ParamType": "string" | "array" | "object";
    "v1.ParamValue": {
      /** @description +listType=atomic */
      arrayVal?: string[];
      objectVal?: {
        [key: string]: string | undefined;
      };
      stringVal?: string;
      /** @description Represents the stored type of ParamValues. */
      type?: components["schemas"]["v1.ParamType"];
    };
    /** @enum {string} */
    "v1.PersistentVolumeAccessMode":
      | "ReadWriteOnce"
      | "ReadOnlyMany"
      | "ReadWriteMany"
      | "ReadWriteOncePod";
    "v1.PersistentVolumeClaim": {
      /** @description APIVersion defines the versioned schema of this representation of an object.
       *     Servers should convert recognized schemas to the latest internal value, and
       *     may reject unrecognized values.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       *     +optional */
      apiVersion?: string;
      /** @description Kind is a string value representing the REST resource this object represents.
       *     Servers may infer this from the endpoint the client submits requests to.
       *     Cannot be updated.
       *     In CamelCase.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       *     +optional */
      kind?: string;
      /** @description Standard object's metadata.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       *     +optional */
      metadata?: components["schemas"]["v1.ObjectMeta"];
      /** @description spec defines the desired characteristics of a volume requested by a pod author.
       *     More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
       *     +optional */
      spec?: components["schemas"]["v1.PersistentVolumeClaimSpec"];
      /** @description status represents the current information/status of a persistent volume claim.
       *     Read-only.
       *     More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
       *     +optional */
      status?: components["schemas"]["v1.PersistentVolumeClaimStatus"];
    };
    "v1.PersistentVolumeClaimCondition": {
      /** @description lastProbeTime is the time we probed the condition.
       *     +optional */
      lastProbeTime?: string;
      /** @description lastTransitionTime is the time the condition transitioned from one status to another.
       *     +optional */
      lastTransitionTime?: string;
      /** @description message is the human-readable message indicating details about last transition.
       *     +optional */
      message?: string;
      /** @description reason is a unique, this should be a short, machine understandable string that gives the reason
       *     for condition's last transition. If it reports "Resizing" that means the underlying
       *     persistent volume is being resized.
       *     +optional */
      reason?: string;
      status?: components["schemas"]["k8s_io_api_core_v1.ConditionStatus"];
      type?: components["schemas"]["v1.PersistentVolumeClaimConditionType"];
    };
    /** @enum {string} */
    "v1.PersistentVolumeClaimConditionType":
      | "Resizing"
      | "FileSystemResizePending"
      | "ModifyVolumeError"
      | "ModifyingVolume";
    /** @enum {string} */
    "v1.PersistentVolumeClaimModifyVolumeStatus": "Pending" | "InProgress" | "Infeasible";
    /** @enum {string} */
    "v1.PersistentVolumeClaimPhase": "Pending" | "Bound" | "Lost";
    "v1.PersistentVolumeClaimSpec": {
      /** @description accessModes contains the desired access modes the volume should have.
       *     More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
       *     +optional
       *     +listType=atomic */
      accessModes?: components["schemas"]["v1.PersistentVolumeAccessMode"][];
      /** @description dataSource field can be used to specify either:
       *     * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
       *     * An existing PVC (PersistentVolumeClaim)
       *     If the provisioner or an external controller can support the specified data source,
       *     it will create a new volume based on the contents of the specified data source.
       *     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
       *     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
       *     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
       *     +optional */
      dataSource?: components["schemas"]["v1.TypedLocalObjectReference"];
      /** @description dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
       *     volume is desired. This may be any object from a non-empty API group (non
       *     core object) or a PersistentVolumeClaim object.
       *     When this field is specified, volume binding will only succeed if the type of
       *     the specified object matches some installed volume populator or dynamic
       *     provisioner.
       *     This field will replace the functionality of the dataSource field and as such
       *     if both fields are non-empty, they must have the same value. For backwards
       *     compatibility, when namespace isn't specified in dataSourceRef,
       *     both fields (dataSource and dataSourceRef) will be set to the same
       *     value automatically if one of them is empty and the other is non-empty.
       *     When namespace is specified in dataSourceRef,
       *     dataSource isn't set to the same value and must be empty.
       *     There are three important differences between dataSource and dataSourceRef:
       *     * While dataSource only allows two specific types of objects, dataSourceRef
       *       allows any non-core object, as well as PersistentVolumeClaim objects.
       *     * While dataSource ignores disallowed values (dropping them), dataSourceRef
       *       preserves all values, and generates an error if a disallowed value is
       *       specified.
       *     * While dataSource only allows local objects, dataSourceRef allows objects
       *       in any namespaces.
       *     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
       *     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
       *     +optional */
      dataSourceRef?: components["schemas"]["v1.TypedObjectReference"];
      /** @description resources represents the minimum resources the volume should have.
       *     If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
       *     that are lower than previous value but must still be higher than capacity recorded in the
       *     status field of the claim.
       *     More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
       *     +optional */
      resources?: components["schemas"]["v1.VolumeResourceRequirements"];
      /** @description selector is a label query over volumes to consider for binding.
       *     +optional */
      selector?: components["schemas"]["v1.LabelSelector"];
      /** @description storageClassName is the name of the StorageClass required by the claim.
       *     More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
       *     +optional */
      storageClassName?: string;
      /** @description volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
       *     If specified, the CSI driver will create or update the volume with the attributes defined
       *     in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
       *     it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
       *     will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
       *     If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
       *     will be set by the persistentvolume controller if it exists.
       *     If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
       *     set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
       *     exists.
       *     More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
       *     (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
       *     +featureGate=VolumeAttributesClass
       *     +optional */
      volumeAttributesClassName?: string;
      /** @description volumeMode defines what type of volume is required by the claim.
       *     Value of Filesystem is implied when not included in claim spec.
       *     +optional */
      volumeMode?: components["schemas"]["v1.PersistentVolumeMode"];
      /** @description volumeName is the binding reference to the PersistentVolume backing this claim.
       *     +optional */
      volumeName?: string;
    };
    "v1.PersistentVolumeClaimStatus": {
      /** @description accessModes contains the actual access modes the volume backing the PVC has.
       *     More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
       *     +optional
       *     +listType=atomic */
      accessModes?: components["schemas"]["v1.PersistentVolumeAccessMode"][];
      /** @description allocatedResourceStatuses stores status of resource being resized for the given PVC.
       *     Key names follow standard Kubernetes label syntax. Valid values are either:
       *     	* Un-prefixed keys:
       *     		- storage - the capacity of the volume.
       *     	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
       *     Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
       *     reserved and hence may not be used.
       *
       *     ClaimResourceStatus can be in any of following states:
       *     	- ControllerResizeInProgress:
       *     		State set when resize controller starts resizing the volume in control-plane.
       *     	- ControllerResizeFailed:
       *     		State set when resize has failed in resize controller with a terminal error.
       *     	- NodeResizePending:
       *     		State set when resize controller has finished resizing the volume but further resizing of
       *     		volume is needed on the node.
       *     	- NodeResizeInProgress:
       *     		State set when kubelet starts resizing the volume.
       *     	- NodeResizeFailed:
       *     		State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
       *     		NodeResizeFailed.
       *     For example: if expanding a PVC for more capacity - this field can be one of the following states:
       *     	- pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
       *          - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
       *          - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
       *          - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
       *          - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
       *     When this field is not set, it means that no resize operation is in progress for the given PVC.
       *
       *     A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
       *     should ignore the update for the purpose it was designed. For example - a controller that
       *     only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
       *     resources associated with PVC.
       *
       *     This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
       *     +featureGate=RecoverVolumeExpansionFailure
       *     +mapType=granular
       *     +optional */
      allocatedResourceStatuses?: {
        [key: string]: components["schemas"]["v1.ClaimResourceStatus"] | undefined;
      };
      /** @description allocatedResources tracks the resources allocated to a PVC including its capacity.
       *     Key names follow standard Kubernetes label syntax. Valid values are either:
       *     	* Un-prefixed keys:
       *     		- storage - the capacity of the volume.
       *     	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
       *     Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
       *     reserved and hence may not be used.
       *
       *     Capacity reported here may be larger than the actual capacity when a volume expansion operation
       *     is requested.
       *     For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
       *     If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
       *     If a volume expansion capacity request is lowered, allocatedResources is only
       *     lowered if there are no expansion operations in progress and if the actual volume capacity
       *     is equal or lower than the requested capacity.
       *
       *     A controller that receives PVC update with previously unknown resourceName
       *     should ignore the update for the purpose it was designed. For example - a controller that
       *     only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
       *     resources associated with PVC.
       *
       *     This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
       *     +featureGate=RecoverVolumeExpansionFailure
       *     +optional */
      allocatedResources?: components["schemas"]["v1.ResourceList"];
      /** @description capacity represents the actual resources of the underlying volume.
       *     +optional */
      capacity?: components["schemas"]["v1.ResourceList"];
      /** @description conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
       *     resized then the Condition will be set to 'Resizing'.
       *     +optional
       *     +patchMergeKey=type
       *     +patchStrategy=merge
       *     +listType=map
       *     +listMapKey=type */
      conditions?: components["schemas"]["v1.PersistentVolumeClaimCondition"][];
      /** @description currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
       *     When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
       *     This is an alpha field and requires enabling VolumeAttributesClass feature.
       *     +featureGate=VolumeAttributesClass
       *     +optional */
      currentVolumeAttributesClassName?: string;
      /** @description ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
       *     When this is unset, there is no ModifyVolume operation being attempted.
       *     This is an alpha field and requires enabling VolumeAttributesClass feature.
       *     +featureGate=VolumeAttributesClass
       *     +optional */
      modifyVolumeStatus?: components["schemas"]["v1.ModifyVolumeStatus"];
      /** @description phase represents the current phase of PersistentVolumeClaim.
       *     +optional */
      phase?: components["schemas"]["v1.PersistentVolumeClaimPhase"];
    };
    "v1.PersistentVolumeClaimTemplate": {
      /** @description May contain labels and annotations that will be copied into the PVC
       *     when creating it. No other fields are allowed and will be rejected during
       *     validation.
       *
       *     +optional */
      metadata?: components["schemas"]["v1.ObjectMeta"];
      /** @description The specification for the PersistentVolumeClaim. The entire content is
       *     copied unchanged into the PVC that gets created from this
       *     template. The same fields as in a PersistentVolumeClaim
       *     are also valid here. */
      spec?: components["schemas"]["v1.PersistentVolumeClaimSpec"];
    };
    "v1.PersistentVolumeClaimVolumeSource": {
      /** @description claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
       *     More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims */
      claimName?: string;
      /** @description readOnly Will force the ReadOnly setting in VolumeMounts.
       *     Default false.
       *     +optional */
      readOnly?: boolean;
    };
    /** @enum {string} */
    "v1.PersistentVolumeMode": "Block" | "Filesystem";
    "v1.PhotonPersistentDiskVolumeSource": {
      /** @description fsType is the filesystem type to mount.
       *     Must be a filesystem type supported by the host operating system.
       *     Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. */
      fsType?: string;
      /** @description pdID is the ID that identifies Photon Controller persistent disk */
      pdID?: string;
    };
    "v1.Pipeline": {
      /** @description APIVersion defines the versioned schema of this representation of an object.
       *     Servers should convert recognized schemas to the latest internal value, and
       *     may reject unrecognized values.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       *     +optional */
      apiVersion?: string;
      /** @description Kind is a string value representing the REST resource this object represents.
       *     Servers may infer this from the endpoint the client submits requests to.
       *     Cannot be updated.
       *     In CamelCase.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       *     +optional */
      kind?: string;
      /** @description +optional */
      metadata?: components["schemas"]["v1.ObjectMeta"];
      /** @description Spec holds the desired state of the Pipeline from the client
       *     +optional */
      spec?: components["schemas"]["v1.PipelineSpec"];
    };
    "v1.PipelineRef": {
      /** @description API version of the referent
       *     +optional */
      apiVersion?: string;
      /** @description Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names */
      name?: string;
      /** @description Params contains the parameters used to identify the
       *     referenced Tekton resource. Example entries might include
       *     "repo" or "path" but the set of params ultimately depends on
       *     the chosen resolver.
       *     +optional
       *     +listType=atomic */
      params?: components["schemas"]["v1.Param"][];
      /** @description Resolver is the name of the resolver that should perform
       *     resolution of the referenced Tekton resource, such as "git".
       *     +optional */
      resolver?: string;
    };
    "v1.PipelineResult": {
      /** @description Description is a human-readable description of the result
       *     +optional */
      description?: string;
      /** @description Name the given name */
      name?: string;
      /** @description Type is the user-specified type of the result.
       *     The possible types are 'string', 'array', and 'object', with 'string' as the default.
       *     'array' and 'object' types are alpha features. */
      type?: components["schemas"]["v1.ResultsType"];
      /** @description Value the expression used to retrieve the value */
      value?: components["schemas"]["v1.ResultValue"];
    };
    "v1.PipelineRun": {
      /** @description APIVersion defines the versioned schema of this representation of an object.
       *     Servers should convert recognized schemas to the latest internal value, and
       *     may reject unrecognized values.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       *     +optional */
      apiVersion?: string;
      /** @description Kind is a string value representing the REST resource this object represents.
       *     Servers may infer this from the endpoint the client submits requests to.
       *     Cannot be updated.
       *     In CamelCase.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       *     +optional */
      kind?: string;
      /** @description +optional */
      metadata?: components["schemas"]["v1.ObjectMeta"];
      /** @description +optional */
      spec?: components["schemas"]["v1.PipelineRunSpec"];
      /** @description +optional */
      status?: components["schemas"]["v1.PipelineRunStatus"];
    };
    "v1.PipelineRunResult": {
      /** @description Name is the result's name as declared by the Pipeline */
      name?: string;
      /** @description Value is the result returned from the execution of this PipelineRun */
      value?: components["schemas"]["v1.ResultValue"];
    };
    "v1.PipelineRunSpec": {
      /** @description Params is a list of parameter names and values.
       *     +listType=atomic */
      params?: components["schemas"]["v1.Param"][];
      /** @description +optional */
      pipelineRef?: components["schemas"]["v1.PipelineRef"];
      /** @description Specifying PipelineSpec can be disabled by setting
       *     `disable-inline-spec` feature flag..
       *     +optional */
      pipelineSpec?: components["schemas"]["v1.PipelineSpec"];
      /** @description Used for cancelling a pipelinerun (and maybe more later on)
       *     +optional */
      status?: string;
      /** @description TaskRunSpecs holds a set of runtime specs
       *     +optional
       *     +listType=atomic */
      taskRunSpecs?: components["schemas"]["v1.PipelineTaskRunSpec"][];
      /** @description TaskRunTemplate represent template of taskrun
       *     +optional */
      taskRunTemplate?: components["schemas"]["v1.PipelineTaskRunTemplate"];
      /** @description Time after which the Pipeline times out.
       *     Currently three keys are accepted in the map
       *     pipeline, tasks and finally
       *     with Timeouts.pipeline >= Timeouts.tasks + Timeouts.finally
       *     +optional */
      timeouts?: components["schemas"]["v1.TimeoutFields"];
      /** @description Workspaces holds a set of workspace bindings that must match names
       *     with those declared in the pipeline.
       *     +optional
       *     +listType=atomic */
      workspaces?: components["schemas"]["v1.WorkspaceBinding"][];
    };
    "v1.PipelineRunStatus": {
      /** @description Annotations is additional Status fields for the Resource to save some
       *     additional State as well as convey more information to the user. This is
       *     roughly akin to Annotations on any k8s resource, just the reconciler conveying
       *     richer information outwards. */
      annotations?: {
        [key: string]: string | undefined;
      };
      /** @description list of TaskRun and Run names, PipelineTask names, and API versions/kinds for children of this PipelineRun.
       *     +optional
       *     +listType=atomic */
      childReferences?: components["schemas"]["v1.ChildStatusReference"][];
      /** @description CompletionTime is the time the PipelineRun completed. */
      completionTime?: string;
      /** @description Conditions the latest available observations of a resource's current state.
       *     +optional
       *     +patchMergeKey=type
       *     +patchStrategy=merge */
      conditions?: components["schemas"]["apis.Condition"][];
      /** @description FinallyStartTime is when all non-finally tasks have been completed and only finally tasks are being executed.
       *     +optional */
      finallyStartTime?: string;
      /** @description ObservedGeneration is the 'Generation' of the Service that
       *     was last processed by the controller.
       *     +optional */
      observedGeneration?: number;
      /** @description PipelineRunSpec contains the exact spec used to instantiate the run */
      pipelineSpec?: components["schemas"]["v1.PipelineSpec"];
      /** @description Provenance contains some key authenticated metadata about how a software artifact was built (what sources, what inputs/outputs, etc.).
       *     +optional */
      provenance?: components["schemas"]["v1.Provenance"];
      /** @description Results are the list of results written out by the pipeline task's containers
       *     +optional
       *     +listType=atomic */
      results?: components["schemas"]["v1.PipelineRunResult"][];
      /** @description list of tasks that were skipped due to when expressions evaluating to false
       *     +optional
       *     +listType=atomic */
      skippedTasks?: components["schemas"]["v1.SkippedTask"][];
      /** @description SpanContext contains tracing span context fields */
      spanContext?: {
        [key: string]: string | undefined;
      };
      /** @description StartTime is the time the PipelineRun is actually started. */
      startTime?: string;
    };
    "v1.PipelineSpec": {
      /** @description Description is a user-facing description of the pipeline that may be
       *     used to populate a UI.
       *     +optional */
      description?: string;
      /** @description DisplayName is a user-facing name of the pipeline that may be
       *     used to populate a UI.
       *     +optional */
      displayName?: string;
      /** @description Finally declares the list of Tasks that execute just before leaving the Pipeline
       *     i.e. either after all Tasks are finished executing successfully
       *     or after a failure which would result in ending the Pipeline
       *     +listType=atomic */
      finally?: components["schemas"]["v1.PipelineTask"][];
      /** @description Params declares a list of input parameters that must be supplied when
       *     this Pipeline is run.
       *     +listType=atomic */
      params?: components["schemas"]["v1.ParamSpec"][];
      /** @description Results are values that this pipeline can output once run
       *     +optional
       *     +listType=atomic */
      results?: components["schemas"]["v1.PipelineResult"][];
      /** @description Tasks declares the graph of Tasks that execute when this Pipeline is run.
       *     +listType=atomic */
      tasks?: components["schemas"]["v1.PipelineTask"][];
      /** @description Workspaces declares a set of named workspaces that are expected to be
       *     provided by a PipelineRun.
       *     +optional
       *     +listType=atomic */
      workspaces?: components["schemas"]["v1.PipelineWorkspaceDeclaration"][];
    };
    "v1.PipelineTask": {
      /** @description Description is the description of this task within the context of a Pipeline.
       *     This description may be used to populate a UI.
       *     +optional */
      description?: string;
      /** @description DisplayName is the display name of this task within the context of a Pipeline.
       *     This display name may be used to populate a UI.
       *     +optional */
      displayName?: string;
      /** @description Matrix declares parameters used to fan out this task.
       *     +optional */
      matrix?: components["schemas"]["v1.Matrix"];
      /** @description Name is the name of this task within the context of a Pipeline. Name is
       *     used as a coordinate with the `from` and `runAfter` fields to establish
       *     the execution order of tasks relative to one another. */
      name?: string;
      /** @description OnError defines the exiting behavior of a PipelineRun on error
       *     can be set to [ continue | stopAndFail ]
       *     +optional */
      onError?: components["schemas"]["v1.PipelineTaskOnErrorType"];
      /** @description Parameters declares parameters passed to this task.
       *     +optional
       *     +listType=atomic */
      params?: components["schemas"]["v1.Param"][];
      /** @description PipelineRef is a reference to a pipeline definition
       *     Note: PipelineRef is in preview mode and not yet supported
       *     +optional */
      pipelineRef?: components["schemas"]["v1.PipelineRef"];
      /** @description PipelineSpec is a specification of a pipeline
       *     Note: PipelineSpec is in preview mode and not yet supported
       *     Specifying PipelineSpec can be disabled by setting
       *     `disable-inline-spec` feature flag..
       *     +optional */
      pipelineSpec?: components["schemas"]["v1.PipelineSpec"];
      /** @description Retries represents how many times this task should be retried in case of task failure: ConditionSucceeded set to False
       *     +optional */
      retries?: number;
      /** @description RunAfter is the list of PipelineTask names that should be executed before
       *     this Task executes. (Used to force a specific ordering in graph execution.)
       *     +optional
       *     +listType=atomic */
      runAfter?: string[];
      /** @description TaskRef is a reference to a task definition.
       *     +optional */
      taskRef?: components["schemas"]["v1.TaskRef"];
      /** @description TaskSpec is a specification of a task
       *     Specifying TaskSpec can be disabled by setting
       *     `disable-inline-spec` feature flag..
       *     +optional */
      taskSpec?: components["schemas"]["v1.EmbeddedTask"];
      /** @description Time after which the TaskRun times out. Defaults to 1 hour.
       *     Refer Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
       *     +optional */
      timeout?: components["schemas"]["v1.Duration"];
      /** @description When is a list of when expressions that need to be true for the task to run
       *     +optional */
      when?: components["schemas"]["v1.WhenExpression"][];
      /** @description Workspaces maps workspaces from the pipeline spec to the workspaces
       *     declared in the Task.
       *     +optional
       *     +listType=atomic */
      workspaces?: components["schemas"]["v1.WorkspacePipelineTaskBinding"][];
    };
    "v1.PipelineTaskMetadata": {
      /** @description +optional */
      annotations?: {
        [key: string]: string | undefined;
      };
      /** @description +optional */
      labels?: {
        [key: string]: string | undefined;
      };
    };
    /** @enum {string} */
    "v1.PipelineTaskOnErrorType": "stopAndFail" | "continue";
    "v1.PipelineTaskRunSpec": {
      /** @description Compute resources to use for this TaskRun */
      computeResources?: components["schemas"]["v1.ResourceRequirements"];
      /** @description +optional */
      metadata?: components["schemas"]["v1.PipelineTaskMetadata"];
      pipelineTaskName?: string;
      podTemplate?: components["schemas"]["pod.PodTemplate"];
      serviceAccountName?: string;
      /** @description +listType=atomic */
      sidecarSpecs?: components["schemas"]["v1.TaskRunSidecarSpec"][];
      /** @description +listType=atomic */
      stepSpecs?: components["schemas"]["v1.TaskRunStepSpec"][];
    };
    "v1.PipelineTaskRunTemplate": {
      /** @description +optional */
      podTemplate?: components["schemas"]["pod.PodTemplate"];
      /** @description +optional */
      serviceAccountName?: string;
    };
    "v1.PipelineWorkspaceDeclaration": {
      /** @description Description is a human readable string describing how the workspace will be
       *     used in the Pipeline. It can be useful to include a bit of detail about which
       *     tasks are intended to have access to the data on the workspace.
       *     +optional */
      description?: string;
      /** @description Name is the name of a workspace to be provided by a PipelineRun. */
      name?: string;
      /** @description Optional marks a Workspace as not being required in PipelineRuns. By default
       *     this field is false and so declared workspaces are required. */
      optional?: boolean;
    };
    "v1.PodAffinity": {
      /** @description The scheduler will prefer to schedule pods to nodes that satisfy
       *     the affinity expressions specified by this field, but it may choose
       *     a node that violates one or more of the expressions. The node that is
       *     most preferred is the one with the greatest sum of weights, i.e.
       *     for each node that meets all of the scheduling requirements (resource
       *     request, requiredDuringScheduling affinity expressions, etc.),
       *     compute a sum by iterating through the elements of this field and adding
       *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
       *     node(s) with the highest sum are the most preferred.
       *     +optional
       *     +listType=atomic */
      preferredDuringSchedulingIgnoredDuringExecution?: components["schemas"]["v1.WeightedPodAffinityTerm"][];
      /** @description If the affinity requirements specified by this field are not met at
       *     scheduling time, the pod will not be scheduled onto the node.
       *     If the affinity requirements specified by this field cease to be met
       *     at some point during pod execution (e.g. due to a pod label update), the
       *     system may or may not try to eventually evict the pod from its node.
       *     When there are multiple elements, the lists of nodes corresponding to each
       *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
       *     +optional
       *     +listType=atomic */
      requiredDuringSchedulingIgnoredDuringExecution?: components["schemas"]["v1.PodAffinityTerm"][];
    };
    "v1.PodAffinityTerm": {
      /** @description A label query over a set of resources, in this case pods.
       *     If it's null, this PodAffinityTerm matches with no Pods.
       *     +optional */
      labelSelector?: components["schemas"]["v1.LabelSelector"];
      /** @description MatchLabelKeys is a set of pod label keys to select which pods will
       *     be taken into consideration. The keys are used to lookup values from the
       *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
       *     to select the group of existing pods which pods will be taken into consideration
       *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
       *     pod labels will be ignored. The default value is empty.
       *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
       *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
       *     This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
       *     +listType=atomic
       *     +optional */
      matchLabelKeys?: string[];
      /** @description MismatchLabelKeys is a set of pod label keys to select which pods will
       *     be taken into consideration. The keys are used to lookup values from the
       *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
       *     to select the group of existing pods which pods will be taken into consideration
       *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
       *     pod labels will be ignored. The default value is empty.
       *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
       *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
       *     This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
       *     +listType=atomic
       *     +optional */
      mismatchLabelKeys?: string[];
      /** @description A label query over the set of namespaces that the term applies to.
       *     The term is applied to the union of the namespaces selected by this field
       *     and the ones listed in the namespaces field.
       *     null selector and null or empty namespaces list means "this pod's namespace".
       *     An empty selector ({}) matches all namespaces.
       *     +optional */
      namespaceSelector?: components["schemas"]["v1.LabelSelector"];
      /** @description namespaces specifies a static list of namespace names that the term applies to.
       *     The term is applied to the union of the namespaces listed in this field
       *     and the ones selected by namespaceSelector.
       *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
       *     +optional
       *     +listType=atomic */
      namespaces?: string[];
      /** @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
       *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
       *     whose value of the label with key topologyKey matches that of any node on which any of the
       *     selected pods is running.
       *     Empty topologyKey is not allowed. */
      topologyKey?: string;
    };
    "v1.PodAntiAffinity": {
      /** @description The scheduler will prefer to schedule pods to nodes that satisfy
       *     the anti-affinity expressions specified by this field, but it may choose
       *     a node that violates one or more of the expressions. The node that is
       *     most preferred is the one with the greatest sum of weights, i.e.
       *     for each node that meets all of the scheduling requirements (resource
       *     request, requiredDuringScheduling anti-affinity expressions, etc.),
       *     compute a sum by iterating through the elements of this field and adding
       *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
       *     node(s) with the highest sum are the most preferred.
       *     +optional
       *     +listType=atomic */
      preferredDuringSchedulingIgnoredDuringExecution?: components["schemas"]["v1.WeightedPodAffinityTerm"][];
      /** @description If the anti-affinity requirements specified by this field are not met at
       *     scheduling time, the pod will not be scheduled onto the node.
       *     If the anti-affinity requirements specified by this field cease to be met
       *     at some point during pod execution (e.g. due to a pod label update), the
       *     system may or may not try to eventually evict the pod from its node.
       *     When there are multiple elements, the lists of nodes corresponding to each
       *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
       *     +optional
       *     +listType=atomic */
      requiredDuringSchedulingIgnoredDuringExecution?: components["schemas"]["v1.PodAffinityTerm"][];
    };
    "v1.PodDNSConfig": {
      /** @description A list of DNS name server IP addresses.
       *     This will be appended to the base nameservers generated from DNSPolicy.
       *     Duplicated nameservers will be removed.
       *     +optional
       *     +listType=atomic */
      nameservers?: string[];
      /** @description A list of DNS resolver options.
       *     This will be merged with the base options generated from DNSPolicy.
       *     Duplicated entries will be removed. Resolution options given in Options
       *     will override those that appear in the base DNSPolicy.
       *     +optional
       *     +listType=atomic */
      options?: components["schemas"]["v1.PodDNSConfigOption"][];
      /** @description A list of DNS search domains for host-name lookup.
       *     This will be appended to the base search paths generated from DNSPolicy.
       *     Duplicated search paths will be removed.
       *     +optional
       *     +listType=atomic */
      searches?: string[];
    };
    "v1.PodDNSConfigOption": {
      /** @description Required. */
      name?: string;
      /** @description +optional */
      value?: string;
    };
    /** @enum {string} */
    "v1.PodFSGroupChangePolicy": "OnRootMismatch" | "Always";
    "v1.PodSecurityContext": {
      /** @description appArmorProfile is the AppArmor options to use by the containers in this pod.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      appArmorProfile?: components["schemas"]["v1.AppArmorProfile"];
      /** @description A special supplemental group that applies to all containers in a pod.
       *     Some volume types allow the Kubelet to change the ownership of that volume
       *     to be owned by the pod:
       *
       *     1. The owning GID will be the FSGroup
       *     2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       *     3. The permission bits are OR'd with rw-rw----
       *
       *     If unset, the Kubelet will not modify the ownership and permissions of any volume.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      fsGroup?: number;
      /** @description fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
       *     before being exposed inside Pod. This field will only apply to
       *     volume types which support fsGroup based ownership(and permissions).
       *     It will have no effect on ephemeral volume types such as: secret, configmaps
       *     and emptydir.
       *     Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      fsGroupChangePolicy?: components["schemas"]["v1.PodFSGroupChangePolicy"];
      /** @description The GID to run the entrypoint of the container process.
       *     Uses runtime default if unset.
       *     May also be set in SecurityContext.  If set in both SecurityContext and
       *     PodSecurityContext, the value specified in SecurityContext takes precedence
       *     for that container.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      runAsGroup?: number;
      /** @description Indicates that the container must run as a non-root user.
       *     If true, the Kubelet will validate the image at runtime to ensure that it
       *     does not run as UID 0 (root) and fail to start the container if it does.
       *     If unset or false, no such validation will be performed.
       *     May also be set in SecurityContext.  If set in both SecurityContext and
       *     PodSecurityContext, the value specified in SecurityContext takes precedence.
       *     +optional */
      runAsNonRoot?: boolean;
      /** @description The UID to run the entrypoint of the container process.
       *     Defaults to user specified in image metadata if unspecified.
       *     May also be set in SecurityContext.  If set in both SecurityContext and
       *     PodSecurityContext, the value specified in SecurityContext takes precedence
       *     for that container.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      runAsUser?: number;
      /** @description The SELinux context to be applied to all containers.
       *     If unspecified, the container runtime will allocate a random SELinux context for each
       *     container.  May also be set in SecurityContext.  If set in
       *     both SecurityContext and PodSecurityContext, the value specified in SecurityContext
       *     takes precedence for that container.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      seLinuxOptions?: components["schemas"]["v1.SELinuxOptions"];
      /** @description The seccomp options to use by the containers in this pod.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      seccompProfile?: components["schemas"]["v1.SeccompProfile"];
      /** @description A list of groups applied to the first process run in each container, in addition
       *     to the container's primary GID, the fsGroup (if specified), and group memberships
       *     defined in the container image for the uid of the container process. If unspecified,
       *     no additional groups are added to any container. Note that group memberships
       *     defined in the container image for the uid of the container process are still effective,
       *     even if they are not included in this list.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional
       *     +listType=atomic */
      supplementalGroups?: number[];
      /** @description Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
       *     sysctls (by the container runtime) might fail to launch.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional
       *     +listType=atomic */
      sysctls?: components["schemas"]["v1.Sysctl"][];
      /** @description The Windows specific settings applied to all containers.
       *     If unspecified, the options within a container's SecurityContext will be used.
       *     If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       *     Note that this field cannot be set when spec.os.name is linux.
       *     +optional */
      windowsOptions?: components["schemas"]["v1.WindowsSecurityContextOptions"];
    };
    "v1.PortworxVolumeSource": {
      /** @description fSType represents the filesystem type to mount
       *     Must be a filesystem type supported by the host operating system.
       *     Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified. */
      fsType?: string;
      /** @description readOnly defaults to false (read/write). ReadOnly here will force
       *     the ReadOnly setting in VolumeMounts.
       *     +optional */
      readOnly?: boolean;
      /** @description volumeID uniquely identifies a Portworx volume */
      volumeID?: string;
    };
    "v1.PreferredSchedulingTerm": {
      /** @description A node selector term, associated with the corresponding weight. */
      preference?: components["schemas"]["v1.NodeSelectorTerm"];
      /** @description Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight?: number;
    };
    "v1.Probe": {
      /** @description Exec specifies the action to take.
       *     +optional */
      exec?: components["schemas"]["v1.ExecAction"];
      /** @description Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *     Defaults to 3. Minimum value is 1.
       *     +optional */
      failureThreshold?: number;
      /** @description GRPC specifies an action involving a GRPC port.
       *     +optional */
      grpc?: components["schemas"]["v1.GRPCAction"];
      /** @description HTTPGet specifies the http request to perform.
       *     +optional */
      httpGet?: components["schemas"]["v1.HTTPGetAction"];
      /** @description Number of seconds after the container has started before liveness probes are initiated.
       *     More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       *     +optional */
      initialDelaySeconds?: number;
      /** @description How often (in seconds) to perform the probe.
       *     Default to 10 seconds. Minimum value is 1.
       *     +optional */
      periodSeconds?: number;
      /** @description Minimum consecutive successes for the probe to be considered successful after having failed.
       *     Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
       *     +optional */
      successThreshold?: number;
      /** @description TCPSocket specifies an action involving a TCP port.
       *     +optional */
      tcpSocket?: components["schemas"]["v1.TCPSocketAction"];
      /** @description Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
       *     The grace period is the duration in seconds after the processes running in the pod are sent
       *     a termination signal and the time when the processes are forcibly halted with a kill signal.
       *     Set this value longer than the expected cleanup time for your process.
       *     If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
       *     value overrides the value provided by the pod spec.
       *     Value must be non-negative integer. The value zero indicates stop immediately via
       *     the kill signal (no opportunity to shut down).
       *     This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
       *     Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
       *     +optional */
      terminationGracePeriodSeconds?: number;
      /** @description Number of seconds after which the probe times out.
       *     Defaults to 1 second. Minimum value is 1.
       *     More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       *     +optional */
      timeoutSeconds?: number;
    };
    /** @enum {string} */
    "v1.ProcMountType": "Default" | "Unmasked";
    "v1.ProjectedVolumeSource": {
      /** @description defaultMode are the mode bits used to set permissions on created files by default.
       *     Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       *     YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       *     Directories within the path are not affected by this setting.
       *     This might be in conflict with other options that affect the file
       *     mode, like fsGroup, and the result can be other mode bits set.
       *     +optional */
      defaultMode?: number;
      /** @description sources is the list of volume projections
       *     +optional
       *     +listType=atomic */
      sources?: components["schemas"]["v1.VolumeProjection"][];
    };
    "v1.PropertySpec": {
      type?: components["schemas"]["v1.ParamType"];
    };
    /** @enum {string} */
    "v1.Protocol": "TCP" | "UDP" | "SCTP";
    "v1.Provenance": {
      /** @description FeatureFlags identifies the feature flags that were used during the task/pipeline run */
      featureFlags?: components["schemas"]["config.FeatureFlags"];
      /** @description RefSource identifies the source where a remote task/pipeline came from. */
      refSource?: components["schemas"]["v1.RefSource"];
    };
    /** @enum {string} */
    "v1.PullPolicy": "Always" | "Never" | "IfNotPresent";
    "v1.QuobyteVolumeSource": {
      /** @description group to map volume access to
       *     Default is no group
       *     +optional */
      group?: string;
      /** @description readOnly here will force the Quobyte volume to be mounted with read-only permissions.
       *     Defaults to false.
       *     +optional */
      readOnly?: boolean;
      /** @description registry represents a single or multiple Quobyte Registry services
       *     specified as a string as host:port pair (multiple entries are separated with commas)
       *     which acts as the central registry for volumes */
      registry?: string;
      /** @description tenant owning the given Quobyte volume in the Backend
       *     Used with dynamically provisioned Quobyte volumes, value is set by the plugin
       *     +optional */
      tenant?: string;
      /** @description user to map volume access to
       *     Defaults to serivceaccount user
       *     +optional */
      user?: string;
      /** @description volume is a string that references an already created Quobyte volume by name. */
      volume?: string;
    };
    "v1.RBDVolumeSource": {
      /** @description fsType is the filesystem type of the volume that you want to mount.
       *     Tip: Ensure that the filesystem type is supported by the host operating system.
       *     Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
       *     TODO: how do we prevent errors in the filesystem from compromising the machine
       *     +optional */
      fsType?: string;
      /** @description image is the rados image name.
       *     More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it */
      image?: string;
      /** @description keyring is the path to key ring for RBDUser.
       *     Default is /etc/ceph/keyring.
       *     More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
       *     +optional */
      keyring?: string;
      /** @description monitors is a collection of Ceph monitors.
       *     More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
       *     +listType=atomic */
      monitors?: string[];
      /** @description pool is the rados pool name.
       *     Default is rbd.
       *     More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
       *     +optional */
      pool?: string;
      /** @description readOnly here will force the ReadOnly setting in VolumeMounts.
       *     Defaults to false.
       *     More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
       *     +optional */
      readOnly?: boolean;
      /** @description secretRef is name of the authentication secret for RBDUser. If provided
       *     overrides keyring.
       *     Default is nil.
       *     More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
       *     +optional */
      secretRef?: components["schemas"]["v1.LocalObjectReference"];
      /** @description user is the rados user name.
       *     Default is admin.
       *     More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
       *     +optional */
      user?: string;
    };
    /** @enum {string} */
    "v1.RecursiveReadOnlyMode": "Disabled" | "IfPossible" | "Enabled";
    "v1.Ref": {
      /** @description Name of the referenced step */
      name?: string;
      /** @description Params contains the parameters used to identify the
       *     referenced Tekton resource. Example entries might include
       *     "repo" or "path" but the set of params ultimately depends on
       *     the chosen resolver.
       *     +optional
       *     +listType=atomic */
      params?: components["schemas"]["v1.Param"][];
      /** @description Resolver is the name of the resolver that should perform
       *     resolution of the referenced Tekton resource, such as "git".
       *     +optional */
      resolver?: string;
    };
    "v1.RefSource": {
      /** @description Digest is a collection of cryptographic digests for the contents of the artifact specified by URI.
       *     Example: {"sha1": "f99d13e554ffcb696dee719fa85b695cb5b0f428"} */
      digest?: {
        [key: string]: string | undefined;
      };
      /** @description EntryPoint identifies the entry point into the build. This is often a path to a
       *     build definition file and/or a target label within that file.
       *     Example: "task/git-clone/0.8/git-clone.yaml" */
      entryPoint?: string;
      /** @description URI indicates the identity of the source of the build definition.
       *     Example: "https://github.com/tektoncd/catalog" */
      uri?: string;
    };
    "v1.ResourceClaim": {
      /** @description Name must match the name of one entry in pod.spec.resourceClaims of
       *     the Pod where this field is used. It makes that resource available
       *     inside a container. */
      name?: string;
    };
    "v1.ResourceFieldSelector": {
      /** @description Container name: required for volumes, optional for env vars
       *     +optional */
      containerName?: string;
      /** @description Specifies the output format of the exposed resources, defaults to "1"
       *     +optional */
      divisor?: components["schemas"]["resource.Quantity"];
      /** @description Required: resource to select */
      resource?: string;
    };
    "v1.ResourceList": {
      [key: string]: components["schemas"]["resource.Quantity"] | undefined;
    };
    "v1.ResourceRequirements": {
      /** @description Claims lists the names of resources, defined in spec.resourceClaims,
       *     that are used by this container.
       *
       *     This is an alpha field and requires enabling the
       *     DynamicResourceAllocation feature gate.
       *
       *     This field is immutable. It can only be set for containers.
       *
       *     +listType=map
       *     +listMapKey=name
       *     +featureGate=DynamicResourceAllocation
       *     +optional */
      claims?: components["schemas"]["v1.ResourceClaim"][];
      /** @description Limits describes the maximum amount of compute resources allowed.
       *     More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       *     +optional */
      limits?: components["schemas"]["v1.ResourceList"];
      /** @description Requests describes the minimum amount of compute resources required.
       *     If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       *     otherwise to an implementation-defined value. Requests cannot exceed Limits.
       *     More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       *     +optional */
      requests?: components["schemas"]["v1.ResourceList"];
    };
    "v1.ResultValue": {
      /** @description +listType=atomic */
      arrayVal?: string[];
      objectVal?: {
        [key: string]: string | undefined;
      };
      stringVal?: string;
      /** @description Represents the stored type of ParamValues. */
      type?: components["schemas"]["v1.ParamType"];
    };
    /** @enum {string} */
    "v1.ResultsType": "string" | "array" | "object";
    "v1.SELinuxOptions": {
      /** @description Level is SELinux level label that applies to the container.
       *     +optional */
      level?: string;
      /** @description Role is a SELinux role label that applies to the container.
       *     +optional */
      role?: string;
      /** @description Type is a SELinux type label that applies to the container.
       *     +optional */
      type?: string;
      /** @description User is a SELinux user label that applies to the container.
       *     +optional */
      user?: string;
    };
    "v1.ScaleIOVolumeSource": {
      /** @description fsType is the filesystem type to mount.
       *     Must be a filesystem type supported by the host operating system.
       *     Ex. "ext4", "xfs", "ntfs".
       *     Default is "xfs".
       *     +optional */
      fsType?: string;
      /** @description gateway is the host address of the ScaleIO API Gateway. */
      gateway?: string;
      /** @description protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
       *     +optional */
      protectionDomain?: string;
      /** @description readOnly Defaults to false (read/write). ReadOnly here will force
       *     the ReadOnly setting in VolumeMounts.
       *     +optional */
      readOnly?: boolean;
      /** @description secretRef references to the secret for ScaleIO user and other
       *     sensitive information. If this is not provided, Login operation will fail. */
      secretRef?: components["schemas"]["v1.LocalObjectReference"];
      /** @description sslEnabled Flag enable/disable SSL communication with Gateway, default false
       *     +optional */
      sslEnabled?: boolean;
      /** @description storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
       *     Default is ThinProvisioned.
       *     +optional */
      storageMode?: string;
      /** @description storagePool is the ScaleIO Storage Pool associated with the protection domain.
       *     +optional */
      storagePool?: string;
      /** @description system is the name of the storage system as configured in ScaleIO. */
      system?: string;
      /** @description volumeName is the name of a volume already created in the ScaleIO system
       *     that is associated with this volume source. */
      volumeName?: string;
    };
    "v1.SeccompProfile": {
      /** @description localhostProfile indicates a profile defined in a file on the node should be used.
       *     The profile must be preconfigured on the node to work.
       *     Must be a descending path, relative to the kubelet's configured seccomp profile location.
       *     Must be set if type is "Localhost". Must NOT be set for any other type.
       *     +optional */
      localhostProfile?: string;
      /** @description type indicates which kind of seccomp profile will be applied.
       *     Valid options are:
       *
       *     Localhost - a profile defined in a file on the node should be used.
       *     RuntimeDefault - the container runtime default profile should be used.
       *     Unconfined - no profile should be applied.
       *     +unionDiscriminator */
      type?: components["schemas"]["v1.SeccompProfileType"];
    };
    /** @enum {string} */
    "v1.SeccompProfileType": "Unconfined" | "RuntimeDefault" | "Localhost";
    "v1.SecretEnvSource": {
      /** @description Name of the referent.
       *     This field is effectively required, but due to backwards compatibility is
       *     allowed to be empty. Instances of this type with an empty value here are
       *     almost certainly wrong.
       *     TODO: Add other useful fields. apiVersion, kind, uid?
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       *     +optional
       *     +default=""
       *     +kubebuilder:default=""
       *     TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896. */
      name?: string;
      /** @description Specify whether the Secret must be defined
       *     +optional */
      optional?: boolean;
    };
    "v1.SecretKeySelector": {
      /** @description The key of the secret to select from.  Must be a valid secret key. */
      key?: string;
      /** @description Name of the referent.
       *     This field is effectively required, but due to backwards compatibility is
       *     allowed to be empty. Instances of this type with an empty value here are
       *     almost certainly wrong.
       *     TODO: Add other useful fields. apiVersion, kind, uid?
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       *     +optional
       *     +default=""
       *     +kubebuilder:default=""
       *     TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896. */
      name?: string;
      /** @description Specify whether the Secret or its key must be defined
       *     +optional */
      optional?: boolean;
    };
    "v1.SecretProjection": {
      /** @description items if unspecified, each key-value pair in the Data field of the referenced
       *     Secret will be projected into the volume as a file whose name is the
       *     key and content is the value. If specified, the listed keys will be
       *     projected into the specified paths, and unlisted keys will not be
       *     present. If a key is specified which is not present in the Secret,
       *     the volume setup will error unless it is marked optional. Paths must be
       *     relative and may not contain the '..' path or start with '..'.
       *     +optional
       *     +listType=atomic */
      items?: components["schemas"]["v1.KeyToPath"][];
      /** @description Name of the referent.
       *     This field is effectively required, but due to backwards compatibility is
       *     allowed to be empty. Instances of this type with an empty value here are
       *     almost certainly wrong.
       *     TODO: Add other useful fields. apiVersion, kind, uid?
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       *     +optional
       *     +default=""
       *     +kubebuilder:default=""
       *     TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896. */
      name?: string;
      /** @description optional field specify whether the Secret or its key must be defined
       *     +optional */
      optional?: boolean;
    };
    "v1.SecretVolumeSource": {
      /** @description defaultMode is Optional: mode bits used to set permissions on created files by default.
       *     Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       *     YAML accepts both octal and decimal values, JSON requires decimal values
       *     for mode bits. Defaults to 0644.
       *     Directories within the path are not affected by this setting.
       *     This might be in conflict with other options that affect the file
       *     mode, like fsGroup, and the result can be other mode bits set.
       *     +optional */
      defaultMode?: number;
      /** @description items If unspecified, each key-value pair in the Data field of the referenced
       *     Secret will be projected into the volume as a file whose name is the
       *     key and content is the value. If specified, the listed keys will be
       *     projected into the specified paths, and unlisted keys will not be
       *     present. If a key is specified which is not present in the Secret,
       *     the volume setup will error unless it is marked optional. Paths must be
       *     relative and may not contain the '..' path or start with '..'.
       *     +optional
       *     +listType=atomic */
      items?: components["schemas"]["v1.KeyToPath"][];
      /** @description optional field specify whether the Secret or its keys must be defined
       *     +optional */
      optional?: boolean;
      /** @description secretName is the name of the secret in the pod's namespace to use.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
       *     +optional */
      secretName?: string;
    };
    "v1.SecurityContext": {
      /** @description AllowPrivilegeEscalation controls whether a process can gain more
       *     privileges than its parent process. This bool directly controls if
       *     the no_new_privs flag will be set on the container process.
       *     AllowPrivilegeEscalation is true always when the container is:
       *     1) run as Privileged
       *     2) has CAP_SYS_ADMIN
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      allowPrivilegeEscalation?: boolean;
      /** @description appArmorProfile is the AppArmor options to use by this container. If set, this profile
       *     overrides the pod's appArmorProfile.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      appArmorProfile?: components["schemas"]["v1.AppArmorProfile"];
      /** @description The capabilities to add/drop when running containers.
       *     Defaults to the default set of capabilities granted by the container runtime.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      capabilities?: components["schemas"]["v1.Capabilities"];
      /** @description Run container in privileged mode.
       *     Processes in privileged containers are essentially equivalent to root on the host.
       *     Defaults to false.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      privileged?: boolean;
      /** @description procMount denotes the type of proc mount to use for the containers.
       *     The default is DefaultProcMount which uses the container runtime defaults for
       *     readonly paths and masked paths.
       *     This requires the ProcMountType feature flag to be enabled.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      procMount?: components["schemas"]["v1.ProcMountType"];
      /** @description Whether this container has a read-only root filesystem.
       *     Default is false.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      readOnlyRootFilesystem?: boolean;
      /** @description The GID to run the entrypoint of the container process.
       *     Uses runtime default if unset.
       *     May also be set in PodSecurityContext.  If set in both SecurityContext and
       *     PodSecurityContext, the value specified in SecurityContext takes precedence.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      runAsGroup?: number;
      /** @description Indicates that the container must run as a non-root user.
       *     If true, the Kubelet will validate the image at runtime to ensure that it
       *     does not run as UID 0 (root) and fail to start the container if it does.
       *     If unset or false, no such validation will be performed.
       *     May also be set in PodSecurityContext.  If set in both SecurityContext and
       *     PodSecurityContext, the value specified in SecurityContext takes precedence.
       *     +optional */
      runAsNonRoot?: boolean;
      /** @description The UID to run the entrypoint of the container process.
       *     Defaults to user specified in image metadata if unspecified.
       *     May also be set in PodSecurityContext.  If set in both SecurityContext and
       *     PodSecurityContext, the value specified in SecurityContext takes precedence.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      runAsUser?: number;
      /** @description The SELinux context to be applied to the container.
       *     If unspecified, the container runtime will allocate a random SELinux context for each
       *     container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
       *     PodSecurityContext, the value specified in SecurityContext takes precedence.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      seLinuxOptions?: components["schemas"]["v1.SELinuxOptions"];
      /** @description The seccomp options to use by this container. If seccomp options are
       *     provided at both the pod & container level, the container options
       *     override the pod options.
       *     Note that this field cannot be set when spec.os.name is windows.
       *     +optional */
      seccompProfile?: components["schemas"]["v1.SeccompProfile"];
      /** @description The Windows specific settings applied to all containers.
       *     If unspecified, the options from the PodSecurityContext will be used.
       *     If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       *     Note that this field cannot be set when spec.os.name is linux.
       *     +optional */
      windowsOptions?: components["schemas"]["v1.WindowsSecurityContextOptions"];
    };
    "v1.ServiceAccountTokenProjection": {
      /** @description audience is the intended audience of the token. A recipient of a token
       *     must identify itself with an identifier specified in the audience of the
       *     token, and otherwise should reject the token. The audience defaults to the
       *     identifier of the apiserver.
       *     +optional */
      audience?: string;
      /** @description expirationSeconds is the requested duration of validity of the service
       *     account token. As the token approaches expiration, the kubelet volume
       *     plugin will proactively rotate the service account token. The kubelet will
       *     start trying to rotate the token if the token is older than 80 percent of
       *     its time to live or if the token is older than 24 hours.Defaults to 1 hour
       *     and must be at least 10 minutes.
       *     +optional */
      expirationSeconds?: number;
      /** @description path is the path relative to the mount point of the file to project the
       *     token into. */
      path?: string;
    };
    "v1.Sidecar": {
      /** @description Arguments to the entrypoint.
       *     The image's CMD is used if this is not provided.
       *     Variable references $(VAR_NAME) are expanded using the Sidecar's environment. If a variable
       *     cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       *     to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       *     produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       *     of whether the variable exists or not. Cannot be updated.
       *     More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       *     +optional
       *     +listType=atomic */
      args?: string[];
      /** @description Entrypoint array. Not executed within a shell.
       *     The image's ENTRYPOINT is used if this is not provided.
       *     Variable references $(VAR_NAME) are expanded using the Sidecar's environment. If a variable
       *     cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       *     to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       *     produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       *     of whether the variable exists or not. Cannot be updated.
       *     More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       *     +optional
       *     +listType=atomic */
      command?: string[];
      /** @description ComputeResources required by this Sidecar.
       *     Cannot be updated.
       *     More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       *     +optional */
      computeResources?: components["schemas"]["v1.ResourceRequirements"];
      /** @description List of environment variables to set in the Sidecar.
       *     Cannot be updated.
       *     +optional
       *     +patchMergeKey=name
       *     +patchStrategy=merge
       *     +listType=atomic */
      env?: components["schemas"]["v1.EnvVar"][];
      /** @description List of sources to populate environment variables in the Sidecar.
       *     The keys defined within a source must be a C_IDENTIFIER. All invalid keys
       *     will be reported as an event when the container is starting. When a key exists in multiple
       *     sources, the value associated with the last source will take precedence.
       *     Values defined by an Env with a duplicate key will take precedence.
       *     Cannot be updated.
       *     +optional
       *     +listType=atomic */
      envFrom?: components["schemas"]["v1.EnvFromSource"][];
      /** @description Image reference name.
       *     More info: https://kubernetes.io/docs/concepts/containers/images
       *     +optional */
      image?: string;
      /** @description Image pull policy.
       *     One of Always, Never, IfNotPresent.
       *     Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
       *     Cannot be updated.
       *     More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
       *     +optional */
      imagePullPolicy?: components["schemas"]["v1.PullPolicy"];
      /** @description Actions that the management system should take in response to Sidecar lifecycle events.
       *     Cannot be updated.
       *     +optional */
      lifecycle?: components["schemas"]["v1.Lifecycle"];
      /** @description Periodic probe of Sidecar liveness.
       *     Container will be restarted if the probe fails.
       *     Cannot be updated.
       *     More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       *     +optional */
      livenessProbe?: components["schemas"]["v1.Probe"];
      /** @description Name of the Sidecar specified as a DNS_LABEL.
       *     Each Sidecar in a Task must have a unique name (DNS_LABEL).
       *     Cannot be updated. */
      name?: string;
      /** @description List of ports to expose from the Sidecar. Exposing a port here gives
       *     the system additional information about the network connections a
       *     container uses, but is primarily informational. Not specifying a port here
       *     DOES NOT prevent that port from being exposed. Any port which is
       *     listening on the default "0.0.0.0" address inside a container will be
       *     accessible from the network.
       *     Cannot be updated.
       *     +optional
       *     +patchMergeKey=containerPort
       *     +patchStrategy=merge
       *     +listType=map
       *     +listMapKey=containerPort
       *     +listMapKey=protocol */
      ports?: components["schemas"]["v1.ContainerPort"][];
      /** @description Periodic probe of Sidecar service readiness.
       *     Container will be removed from service endpoints if the probe fails.
       *     Cannot be updated.
       *     More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       *     +optional */
      readinessProbe?: components["schemas"]["v1.Probe"];
      /** @description Script is the contents of an executable file to execute.
       *
       *     If Script is not empty, the Step cannot have an Command or Args.
       *     +optional */
      script?: string;
      /** @description SecurityContext defines the security options the Sidecar should be run with.
       *     If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
       *     More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       *     +optional */
      securityContext?: components["schemas"]["v1.SecurityContext"];
      /** @description StartupProbe indicates that the Pod the Sidecar is running in has successfully initialized.
       *     If specified, no other probes are executed until this completes successfully.
       *     If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       *     This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       *     when it might take a long time to load data or warm a cache, than during steady-state operation.
       *     This cannot be updated.
       *     More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       *     +optional */
      startupProbe?: components["schemas"]["v1.Probe"];
      /** @description Whether this Sidecar should allocate a buffer for stdin in the container runtime. If this
       *     is not set, reads from stdin in the Sidecar will always result in EOF.
       *     Default is false.
       *     +optional */
      stdin?: boolean;
      /** @description Whether the container runtime should close the stdin channel after it has been opened by
       *     a single attach. When stdin is true the stdin stream will remain open across multiple attach
       *     sessions. If stdinOnce is set to true, stdin is opened on Sidecar start, is empty until the
       *     first client attaches to stdin, and then remains open and accepts data until the client disconnects,
       *     at which time stdin is closed and remains closed until the Sidecar is restarted. If this
       *     flag is false, a container processes that reads from stdin will never receive an EOF.
       *     Default is false
       *     +optional */
      stdinOnce?: boolean;
      /** @description Optional: Path at which the file to which the Sidecar's termination message
       *     will be written is mounted into the Sidecar's filesystem.
       *     Message written is intended to be brief final status, such as an assertion failure message.
       *     Will be truncated by the node if greater than 4096 bytes. The total message length across
       *     all containers will be limited to 12kb.
       *     Defaults to /dev/termination-log.
       *     Cannot be updated.
       *     +optional */
      terminationMessagePath?: string;
      /** @description Indicate how the termination message should be populated. File will use the contents of
       *     terminationMessagePath to populate the Sidecar status message on both success and failure.
       *     FallbackToLogsOnError will use the last chunk of Sidecar log output if the termination
       *     message file is empty and the Sidecar exited with an error.
       *     The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       *     Defaults to File.
       *     Cannot be updated.
       *     +optional */
      terminationMessagePolicy?: components["schemas"]["v1.TerminationMessagePolicy"];
      /** @description Whether this Sidecar should allocate a TTY for itself, also requires 'stdin' to be true.
       *     Default is false.
       *     +optional */
      tty?: boolean;
      /** @description volumeDevices is the list of block devices to be used by the Sidecar.
       *     +patchMergeKey=devicePath
       *     +patchStrategy=merge
       *     +optional
       *     +listType=atomic */
      volumeDevices?: components["schemas"]["v1.VolumeDevice"][];
      /** @description Volumes to mount into the Sidecar's filesystem.
       *     Cannot be updated.
       *     +optional
       *     +patchMergeKey=mountPath
       *     +patchStrategy=merge
       *     +listType=atomic */
      volumeMounts?: components["schemas"]["v1.VolumeMount"][];
      /** @description Sidecar's working directory.
       *     If not specified, the container runtime's default will be used, which
       *     might be configured in the container image.
       *     Cannot be updated.
       *     +optional */
      workingDir?: string;
      /** @description This is an alpha field. You must set the "enable-api-fields" feature flag to "alpha"
       *     for this field to be supported.
       *
       *     Workspaces is a list of workspaces from the Task that this Sidecar wants
       *     exclusive access to. Adding a workspace to this list means that any
       *     other Step or Sidecar that does not also request this Workspace will
       *     not have access to it.
       *     +optional
       *     +listType=atomic */
      workspaces?: components["schemas"]["v1.WorkspaceUsage"][];
    };
    "v1.SidecarState": {
      container?: string;
      imageID?: string;
      name?: string;
      /** @description Details about a running container
       *     +optional */
      running?: components["schemas"]["v1.ContainerStateRunning"];
      /** @description Details about a terminated container
       *     +optional */
      terminated?: components["schemas"]["v1.ContainerStateTerminated"];
      /** @description Details about a waiting container
       *     +optional */
      waiting?: components["schemas"]["v1.ContainerStateWaiting"];
    };
    "v1.SkippedTask": {
      /** @description Name is the Pipeline Task name */
      name?: string;
      /** @description Reason is the cause of the PipelineTask being skipped. */
      reason?: components["schemas"]["v1.SkippingReason"];
      /** @description WhenExpressions is the list of checks guarding the execution of the PipelineTask
       *     +optional
       *     +listType=atomic */
      whenExpressions?: components["schemas"]["v1.WhenExpression"][];
    };
    /** @enum {string} */
    "v1.SkippingReason":
      | "When Expressions evaluated to false"
      | "Parent Tasks were skipped"
      | "PipelineRun was stopping"
      | "PipelineRun was gracefully cancelled"
      | "PipelineRun was gracefully stopped"
      | "Results were missing"
      | "PipelineRun timeout has been reached"
      | "PipelineRun Tasks timeout has been reached"
      | "PipelineRun Finally timeout has been reached"
      | "Matrix Parameters have an empty array"
      | "None";
    "v1.SleepAction": {
      /** @description Seconds is the number of seconds to sleep. */
      seconds?: number;
    };
    "v1.Step": {
      /** @description Arguments to the entrypoint.
       *     The image's CMD is used if this is not provided.
       *     Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       *     cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       *     to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       *     produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       *     of whether the variable exists or not. Cannot be updated.
       *     More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       *     +optional
       *     +listType=atomic */
      args?: string[];
      /** @description Entrypoint array. Not executed within a shell.
       *     The image's ENTRYPOINT is used if this is not provided.
       *     Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       *     cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       *     to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       *     produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       *     of whether the variable exists or not. Cannot be updated.
       *     More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       *     +optional
       *     +listType=atomic */
      command?: string[];
      /** @description ComputeResources required by this Step.
       *     Cannot be updated.
       *     More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       *     +optional */
      computeResources?: components["schemas"]["v1.ResourceRequirements"];
      /** @description List of environment variables to set in the Step.
       *     Cannot be updated.
       *     +optional
       *     +patchMergeKey=name
       *     +patchStrategy=merge
       *     +listType=atomic */
      env?: components["schemas"]["v1.EnvVar"][];
      /** @description List of sources to populate environment variables in the Step.
       *     The keys defined within a source must be a C_IDENTIFIER. All invalid keys
       *     will be reported as an event when the Step is starting. When a key exists in multiple
       *     sources, the value associated with the last source will take precedence.
       *     Values defined by an Env with a duplicate key will take precedence.
       *     Cannot be updated.
       *     +optional
       *     +listType=atomic */
      envFrom?: components["schemas"]["v1.EnvFromSource"][];
      /** @description Docker image name.
       *     More info: https://kubernetes.io/docs/concepts/containers/images
       *     +optional */
      image?: string;
      /** @description Image pull policy.
       *     One of Always, Never, IfNotPresent.
       *     Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
       *     Cannot be updated.
       *     More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
       *     +optional */
      imagePullPolicy?: components["schemas"]["v1.PullPolicy"];
      /** @description Name of the Step specified as a DNS_LABEL.
       *     Each Step in a Task must have a unique name. */
      name?: string;
      /** @description OnError defines the exiting behavior of a container on error
       *     can be set to [ continue | stopAndFail ] */
      onError?: components["schemas"]["v1.OnErrorType"];
      /** @description Params declares parameters passed to this step action.
       *     +optional
       *     +listType=atomic */
      params?: components["schemas"]["v1.Param"][];
      /** @description Contains the reference to an existing StepAction.
       *     +optional */
      ref?: components["schemas"]["v1.Ref"];
      /** @description Results declares StepResults produced by the Step.
       *
       *     This is field is at an ALPHA stability level and gated by "enable-step-actions" feature flag.
       *
       *     It can be used in an inlined Step when used to store Results to $(step.results.resultName.path).
       *     It cannot be used when referencing StepActions using [v1.Step.Ref].
       *     The Results declared by the StepActions will be stored here instead.
       *     +optional
       *     +listType=atomic */
      results?: components["schemas"]["v1.StepResult"][];
      /** @description Script is the contents of an executable file to execute.
       *
       *     If Script is not empty, the Step cannot have an Command and the Args will be passed to the Script.
       *     +optional */
      script?: string;
      /** @description SecurityContext defines the security options the Step should be run with.
       *     If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
       *     More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       *     +optional */
      securityContext?: components["schemas"]["v1.SecurityContext"];
      /** @description Stores configuration for the stderr stream of the step.
       *     +optional */
      stderrConfig?: components["schemas"]["v1.StepOutputConfig"];
      /** @description Stores configuration for the stdout stream of the step.
       *     +optional */
      stdoutConfig?: components["schemas"]["v1.StepOutputConfig"];
      /** @description Timeout is the time after which the step times out. Defaults to never.
       *     Refer to Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
       *     +optional */
      timeout?: components["schemas"]["v1.Duration"];
      /** @description volumeDevices is the list of block devices to be used by the Step.
       *     +patchMergeKey=devicePath
       *     +patchStrategy=merge
       *     +optional
       *     +listType=atomic */
      volumeDevices?: components["schemas"]["v1.VolumeDevice"][];
      /** @description Volumes to mount into the Step's filesystem.
       *     Cannot be updated.
       *     +optional
       *     +patchMergeKey=mountPath
       *     +patchStrategy=merge
       *     +listType=atomic */
      volumeMounts?: components["schemas"]["v1.VolumeMount"][];
      /** @description Step's working directory.
       *     If not specified, the container runtime's default will be used, which
       *     might be configured in the container image.
       *     Cannot be updated.
       *     +optional */
      workingDir?: string;
      /** @description This is an alpha field. You must set the "enable-api-fields" feature flag to "alpha"
       *     for this field to be supported.
       *
       *     Workspaces is a list of workspaces from the Task that this Step wants
       *     exclusive access to. Adding a workspace to this list means that any
       *     other Step or Sidecar that does not also request this Workspace will
       *     not have access to it.
       *     +optional
       *     +listType=atomic */
      workspaces?: components["schemas"]["v1.WorkspaceUsage"][];
    };
    "v1.StepOutputConfig": {
      /** @description Path to duplicate stdout stream to on container's local filesystem.
       *     +optional */
      path?: string;
    };
    "v1.StepResult": {
      /** @description Description is a human-readable description of the result
       *     +optional */
      description?: string;
      /** @description Name the given name */
      name?: string;
      /** @description Properties is the JSON Schema properties to support key-value pairs results.
       *     +optional */
      properties?: {
        [key: string]: components["schemas"]["v1.PropertySpec"] | undefined;
      };
      /** @description The possible types are 'string', 'array', and 'object', with 'string' as the default.
       *     +optional */
      type?: components["schemas"]["v1.ResultsType"];
    };
    "v1.StepState": {
      container?: string;
      imageID?: string;
      inputs?: components["schemas"]["v1.TaskRunStepArtifact"][];
      name?: string;
      outputs?: components["schemas"]["v1.TaskRunStepArtifact"][];
      results?: components["schemas"]["v1.TaskRunStepResult"][];
      /** @description Details about a running container
       *     +optional */
      running?: components["schemas"]["v1.ContainerStateRunning"];
      /** @description Details about a terminated container
       *     +optional */
      terminated?: components["schemas"]["v1.ContainerStateTerminated"];
      terminationReason?: string;
      /** @description Details about a waiting container
       *     +optional */
      waiting?: components["schemas"]["v1.ContainerStateWaiting"];
    };
    "v1.StepTemplate": {
      /** @description Arguments to the entrypoint.
       *     The image's CMD is used if this is not provided.
       *     Variable references $(VAR_NAME) are expanded using the Step's environment. If a variable
       *     cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       *     to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       *     produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       *     of whether the variable exists or not. Cannot be updated.
       *     More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       *     +optional
       *     +listType=atomic */
      args?: string[];
      /** @description Entrypoint array. Not executed within a shell.
       *     The image's ENTRYPOINT is used if this is not provided.
       *     Variable references $(VAR_NAME) are expanded using the Step's environment. If a variable
       *     cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       *     to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       *     produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       *     of whether the variable exists or not. Cannot be updated.
       *     More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       *     +optional
       *     +listType=atomic */
      command?: string[];
      /** @description ComputeResources required by this Step.
       *     Cannot be updated.
       *     More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       *     +optional */
      computeResources?: components["schemas"]["v1.ResourceRequirements"];
      /** @description List of environment variables to set in the Step.
       *     Cannot be updated.
       *     +optional
       *     +patchMergeKey=name
       *     +patchStrategy=merge
       *     +listType=atomic */
      env?: components["schemas"]["v1.EnvVar"][];
      /** @description List of sources to populate environment variables in the Step.
       *     The keys defined within a source must be a C_IDENTIFIER. All invalid keys
       *     will be reported as an event when the Step is starting. When a key exists in multiple
       *     sources, the value associated with the last source will take precedence.
       *     Values defined by an Env with a duplicate key will take precedence.
       *     Cannot be updated.
       *     +optional
       *     +listType=atomic */
      envFrom?: components["schemas"]["v1.EnvFromSource"][];
      /** @description Image reference name.
       *     More info: https://kubernetes.io/docs/concepts/containers/images
       *     +optional */
      image?: string;
      /** @description Image pull policy.
       *     One of Always, Never, IfNotPresent.
       *     Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
       *     Cannot be updated.
       *     More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
       *     +optional */
      imagePullPolicy?: components["schemas"]["v1.PullPolicy"];
      /** @description SecurityContext defines the security options the Step should be run with.
       *     If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
       *     More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       *     +optional */
      securityContext?: components["schemas"]["v1.SecurityContext"];
      /** @description volumeDevices is the list of block devices to be used by the Step.
       *     +patchMergeKey=devicePath
       *     +patchStrategy=merge
       *     +optional
       *     +listType=atomic */
      volumeDevices?: components["schemas"]["v1.VolumeDevice"][];
      /** @description Volumes to mount into the Step's filesystem.
       *     Cannot be updated.
       *     +optional
       *     +patchMergeKey=mountPath
       *     +patchStrategy=merge
       *     +listType=atomic */
      volumeMounts?: components["schemas"]["v1.VolumeMount"][];
      /** @description Step's working directory.
       *     If not specified, the container runtime's default will be used, which
       *     might be configured in the container image.
       *     Cannot be updated.
       *     +optional */
      workingDir?: string;
    };
    /** @enum {string} */
    "v1.StorageMedium": "" | "Memory" | "HugePages" | "HugePages-";
    "v1.StorageOSVolumeSource": {
      /** @description fsType is the filesystem type to mount.
       *     Must be a filesystem type supported by the host operating system.
       *     Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
       *     +optional */
      fsType?: string;
      /** @description readOnly defaults to false (read/write). ReadOnly here will force
       *     the ReadOnly setting in VolumeMounts.
       *     +optional */
      readOnly?: boolean;
      /** @description secretRef specifies the secret to use for obtaining the StorageOS API
       *     credentials.  If not specified, default values will be attempted.
       *     +optional */
      secretRef?: components["schemas"]["v1.LocalObjectReference"];
      /** @description volumeName is the human-readable name of the StorageOS volume.  Volume
       *     names are only unique within a namespace. */
      volumeName?: string;
      /** @description volumeNamespace specifies the scope of the volume within StorageOS.  If no
       *     namespace is specified then the Pod's namespace will be used.  This allows the
       *     Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
       *     Set VolumeName to any name to override the default behaviour.
       *     Set to "default" if you are not using namespaces within StorageOS.
       *     Namespaces that do not pre-exist within StorageOS will be created.
       *     +optional */
      volumeNamespace?: string;
    };
    "v1.Sysctl": {
      /** @description Name of a property to set */
      name?: string;
      /** @description Value of a property to set */
      value?: string;
    };
    "v1.TCPSocketAction": {
      /** @description Optional: Host name to connect to, defaults to the pod IP.
       *     +optional */
      host?: string;
      /** @description Number or name of the port to access on the container.
       *     Number must be in the range 1 to 65535.
       *     Name must be an IANA_SVC_NAME. */
      port?: components["schemas"]["intstr.IntOrString"];
    };
    /** @enum {string} */
    "v1.TaintEffect": "NoSchedule" | "PreferNoSchedule" | "NoExecute";
    "v1.Task": {
      /** @description APIVersion defines the versioned schema of this representation of an object.
       *     Servers should convert recognized schemas to the latest internal value, and
       *     may reject unrecognized values.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       *     +optional */
      apiVersion?: string;
      /** @description Kind is a string value representing the REST resource this object represents.
       *     Servers may infer this from the endpoint the client submits requests to.
       *     Cannot be updated.
       *     In CamelCase.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       *     +optional */
      kind?: string;
      /** @description +optional */
      metadata?: components["schemas"]["v1.ObjectMeta"];
      /** @description Spec holds the desired state of the Task from the client
       *     +optional */
      spec?: components["schemas"]["v1.TaskSpec"];
    };
    "v1.TaskBreakpoints": {
      /** @description if enabled, pause TaskRun on failure of a step
       *     failed step will not exit
       *     +optional */
      onFailure?: string;
    };
    /** @enum {string} */
    "v1.TaskKind": "Task" | "ClusterTask";
    "v1.TaskRef": {
      /** @description API version of the referent
       *     Note: A Task with non-empty APIVersion and Kind is considered a Custom Task
       *     +optional */
      apiVersion?: string;
      /** @description TaskKind indicates the Kind of the Task:
       *     1. Namespaced Task when Kind is set to "Task". If Kind is "", it defaults to "Task".
       *     2. Custom Task when Kind is non-empty and APIVersion is non-empty */
      kind?: components["schemas"]["v1.TaskKind"];
      /** @description Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names */
      name?: string;
      /** @description Params contains the parameters used to identify the
       *     referenced Tekton resource. Example entries might include
       *     "repo" or "path" but the set of params ultimately depends on
       *     the chosen resolver.
       *     +optional
       *     +listType=atomic */
      params?: components["schemas"]["v1.Param"][];
      /** @description Resolver is the name of the resolver that should perform
       *     resolution of the referenced Tekton resource, such as "git".
       *     +optional */
      resolver?: string;
    };
    "v1.TaskResult": {
      /** @description Description is a human-readable description of the result
       *     +optional */
      description?: string;
      /** @description Name the given name */
      name?: string;
      /** @description Properties is the JSON Schema properties to support key-value pairs results.
       *     +optional */
      properties?: {
        [key: string]: components["schemas"]["v1.PropertySpec"] | undefined;
      };
      /** @description Type is the user-specified type of the result. The possible type
       *     is currently "string" and will support "array" in following work.
       *     +optional */
      type?: components["schemas"]["v1.ResultsType"];
      /** @description Value the expression used to retrieve the value of the result from an underlying Step.
       *     +optional */
      value?: components["schemas"]["v1.ResultValue"];
    };
    "v1.TaskRun": {
      /** @description APIVersion defines the versioned schema of this representation of an object.
       *     Servers should convert recognized schemas to the latest internal value, and
       *     may reject unrecognized values.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       *     +optional */
      apiVersion?: string;
      /** @description Kind is a string value representing the REST resource this object represents.
       *     Servers may infer this from the endpoint the client submits requests to.
       *     Cannot be updated.
       *     In CamelCase.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       *     +optional */
      kind?: string;
      /** @description +optional */
      metadata?: components["schemas"]["v1.ObjectMeta"];
      /** @description +optional */
      spec?: components["schemas"]["v1.TaskRunSpec"];
      /** @description +optional */
      status?: components["schemas"]["v1.TaskRunStatus"];
    };
    "v1.TaskRunDebug": {
      /** @description +optional */
      breakpoints?: components["schemas"]["v1.TaskBreakpoints"];
    };
    "v1.TaskRunResult": {
      /** @description Name the given name */
      name?: string;
      /** @description Type is the user-specified type of the result. The possible type
       *     is currently "string" and will support "array" in following work.
       *     +optional */
      type?: components["schemas"]["v1.ResultsType"];
      /** @description Value the given value of the result */
      value?: components["schemas"]["v1.ResultValue"];
    };
    "v1.TaskRunSidecarSpec": {
      /** @description The resource requirements to apply to the Sidecar. */
      computeResources?: components["schemas"]["v1.ResourceRequirements"];
      /** @description The name of the Sidecar to override. */
      name?: string;
    };
    "v1.TaskRunSpec": {
      /** @description Compute resources to use for this TaskRun */
      computeResources?: components["schemas"]["v1.ResourceRequirements"];
      /** @description +optional */
      debug?: components["schemas"]["v1.TaskRunDebug"];
      /** @description +optional
       *     +listType=atomic */
      params?: components["schemas"]["v1.Param"][];
      /** @description PodTemplate holds pod specific configuration */
      podTemplate?: components["schemas"]["pod.PodTemplate"];
      /** @description Retries represents how many times this TaskRun should be retried in the event of task failure.
       *     +optional */
      retries?: number;
      /** @description +optional */
      serviceAccountName?: string;
      /** @description Specs to apply to Sidecars in this TaskRun.
       *     If a field is specified in both a Sidecar and a SidecarSpec,
       *     the value from the SidecarSpec will be used.
       *     This field is only supported when the alpha feature gate is enabled.
       *     +optional
       *     +listType=atomic */
      sidecarSpecs?: components["schemas"]["v1.TaskRunSidecarSpec"][];
      /** @description Used for cancelling a TaskRun (and maybe more later on)
       *     +optional */
      status?: string;
      /** @description Status message for cancellation.
       *     +optional */
      statusMessage?: components["schemas"]["v1.TaskRunSpecStatusMessage"];
      /** @description Specs to apply to Steps in this TaskRun.
       *     If a field is specified in both a Step and a StepSpec,
       *     the value from the StepSpec will be used.
       *     This field is only supported when the alpha feature gate is enabled.
       *     +optional
       *     +listType=atomic */
      stepSpecs?: components["schemas"]["v1.TaskRunStepSpec"][];
      /** @description no more than one of the TaskRef and TaskSpec may be specified.
       *     +optional */
      taskRef?: components["schemas"]["v1.TaskRef"];
      /** @description Specifying PipelineSpec can be disabled by setting
       *     `disable-inline-spec` feature flag..
       *     +optional */
      taskSpec?: components["schemas"]["v1.TaskSpec"];
      /** @description Time after which one retry attempt times out. Defaults to 1 hour.
       *     Refer Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
       *     +optional */
      timeout?: components["schemas"]["v1.Duration"];
      /** @description Workspaces is a list of WorkspaceBindings from volumes to workspaces.
       *     +optional
       *     +listType=atomic */
      workspaces?: components["schemas"]["v1.WorkspaceBinding"][];
    };
    /** @enum {string} */
    "v1.TaskRunSpecStatusMessage":
      | "TaskRun cancelled as the PipelineRun it belongs to has been cancelled."
      | "TaskRun cancelled as the PipelineRun it belongs to has timed out.";
    "v1.TaskRunStatus": {
      /** @description Annotations is additional Status fields for the Resource to save some
       *     additional State as well as convey more information to the user. This is
       *     roughly akin to Annotations on any k8s resource, just the reconciler conveying
       *     richer information outwards. */
      annotations?: {
        [key: string]: string | undefined;
      };
      /** @description CompletionTime is the time the build completed. */
      completionTime?: string;
      /** @description Conditions the latest available observations of a resource's current state.
       *     +optional
       *     +patchMergeKey=type
       *     +patchStrategy=merge */
      conditions?: components["schemas"]["apis.Condition"][];
      /** @description ObservedGeneration is the 'Generation' of the Service that
       *     was last processed by the controller.
       *     +optional */
      observedGeneration?: number;
      /** @description PodName is the name of the pod responsible for executing this task's steps. */
      podName?: string;
      /** @description Provenance contains some key authenticated metadata about how a software artifact was built (what sources, what inputs/outputs, etc.).
       *     +optional */
      provenance?: components["schemas"]["v1.Provenance"];
      /** @description Results are the list of results written out by the task's containers
       *     +optional
       *     +listType=atomic */
      results?: components["schemas"]["v1.TaskRunResult"][];
      /** @description RetriesStatus contains the history of TaskRunStatus in case of a retry in order to keep record of failures.
       *     All TaskRunStatus stored in RetriesStatus will have no date within the RetriesStatus as is redundant.
       *     +optional
       *     +listType=atomic */
      retriesStatus?: components["schemas"]["v1.TaskRunStatus"][];
      /** @description The list has one entry per sidecar in the manifest. Each entry is
       *     represents the imageid of the corresponding sidecar.
       *     +listType=atomic */
      sidecars?: components["schemas"]["v1.SidecarState"][];
      /** @description SpanContext contains tracing span context fields */
      spanContext?: {
        [key: string]: string | undefined;
      };
      /** @description StartTime is the time the build is actually started. */
      startTime?: string;
      /** @description Steps describes the state of each build step container.
       *     +optional
       *     +listType=atomic */
      steps?: components["schemas"]["v1.StepState"][];
      /** @description TaskSpec contains the Spec from the dereferenced Task definition used to instantiate this TaskRun. */
      taskSpec?: components["schemas"]["v1.TaskSpec"];
    };
    "v1.TaskRunStepArtifact": {
      /** @description The artifact's identifying category name */
      name?: string;
      /** @description A collection of values related to the artifact */
      values?: components["schemas"]["v1.ArtifactValue"][];
    };
    "v1.TaskRunStepResult": {
      /** @description Name the given name */
      name?: string;
      /** @description Type is the user-specified type of the result. The possible type
       *     is currently "string" and will support "array" in following work.
       *     +optional */
      type?: components["schemas"]["v1.ResultsType"];
      /** @description Value the given value of the result */
      value?: components["schemas"]["v1.ResultValue"];
    };
    "v1.TaskRunStepSpec": {
      /** @description The resource requirements to apply to the Step. */
      computeResources?: components["schemas"]["v1.ResourceRequirements"];
      /** @description The name of the Step to override. */
      name?: string;
    };
    "v1.TaskSpec": {
      /** @description Description is a user-facing description of the task that may be
       *     used to populate a UI.
       *     +optional */
      description?: string;
      /** @description DisplayName is a user-facing name of the task that may be
       *     used to populate a UI.
       *     +optional */
      displayName?: string;
      /** @description Params is a list of input parameters required to run the task. Params
       *     must be supplied as inputs in TaskRuns unless they declare a default
       *     value.
       *     +optional
       *     +listType=atomic */
      params?: components["schemas"]["v1.ParamSpec"][];
      /** @description Results are values that this Task can output
       *     +listType=atomic */
      results?: components["schemas"]["v1.TaskResult"][];
      /** @description Sidecars are run alongside the Task's step containers. They begin before
       *     the steps start and end after the steps complete.
       *     +listType=atomic */
      sidecars?: components["schemas"]["v1.Sidecar"][];
      /** @description StepTemplate can be used as the basis for all step containers within the
       *     Task, so that the steps inherit settings on the base container. */
      stepTemplate?: components["schemas"]["v1.StepTemplate"];
      /** @description Steps are the steps of the build; each step is run sequentially with the
       *     source mounted into /workspace.
       *     +listType=atomic */
      steps?: components["schemas"]["v1.Step"][];
      /** @description Volumes is a collection of volumes that are available to mount into the
       *     steps of the build.
       *     +listType=atomic */
      volumes?: components["schemas"]["v1.Volume"][];
      /** @description Workspaces are the volumes that this Task requires.
       *     +listType=atomic */
      workspaces?: components["schemas"]["v1.WorkspaceDeclaration"][];
    };
    /** @enum {string} */
    "v1.TerminationMessagePolicy": "File" | "FallbackToLogsOnError";
    "v1.TimeoutFields": {
      /** @description Finally sets the maximum allowed duration of this pipeline's finally */
      finally?: components["schemas"]["v1.Duration"];
      /** @description Pipeline sets the maximum allowed duration for execution of the entire pipeline. The sum of individual timeouts for tasks and finally must not exceed this value. */
      pipeline?: components["schemas"]["v1.Duration"];
      /** @description Tasks sets the maximum allowed duration of this pipeline's tasks */
      tasks?: components["schemas"]["v1.Duration"];
    };
    "v1.Toleration": {
      /** @description Effect indicates the taint effect to match. Empty means match all taint effects.
       *     When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       *     +optional */
      effect?: components["schemas"]["v1.TaintEffect"];
      /** @description Key is the taint key that the toleration applies to. Empty means match all taint keys.
       *     If the key is empty, operator must be Exists; this combination means to match all values and all keys.
       *     +optional */
      key?: string;
      /** @description Operator represents a key's relationship to the value.
       *     Valid operators are Exists and Equal. Defaults to Equal.
       *     Exists is equivalent to wildcard for value, so that a pod can
       *     tolerate all taints of a particular category.
       *     +optional */
      operator?: components["schemas"]["v1.TolerationOperator"];
      /** @description TolerationSeconds represents the period of time the toleration (which must be
       *     of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
       *     it is not set, which means tolerate the taint forever (do not evict). Zero and
       *     negative values will be treated as 0 (evict immediately) by the system.
       *     +optional */
      tolerationSeconds?: number;
      /** @description Value is the taint value the toleration matches to.
       *     If the operator is Exists, the value should be empty, otherwise just a regular string.
       *     +optional */
      value?: string;
    };
    /** @enum {string} */
    "v1.TolerationOperator": "Exists" | "Equal";
    "v1.TopologySpreadConstraint": {
      /** @description LabelSelector is used to find matching pods.
       *     Pods that match this label selector are counted to determine the number of pods
       *     in their corresponding topology domain.
       *     +optional */
      labelSelector?: components["schemas"]["v1.LabelSelector"];
      /** @description MatchLabelKeys is a set of pod label keys to select the pods over which
       *     spreading will be calculated. The keys are used to lookup values from the
       *     incoming pod labels, those key-value labels are ANDed with labelSelector
       *     to select the group of existing pods over which spreading will be calculated
       *     for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
       *     MatchLabelKeys cannot be set when LabelSelector isn't set.
       *     Keys that don't exist in the incoming pod labels will
       *     be ignored. A null or empty list means only match against labelSelector.
       *
       *     This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
       *     +listType=atomic
       *     +optional */
      matchLabelKeys?: string[];
      /** @description MaxSkew describes the degree to which pods may be unevenly distributed.
       *     When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
       *     between the number of matching pods in the target topology and the global minimum.
       *     The global minimum is the minimum number of matching pods in an eligible domain
       *     or zero if the number of eligible domains is less than MinDomains.
       *     For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
       *     labelSelector spread as 2/2/1:
       *     In this case, the global minimum is 1.
       *     +-------+-------+-------+
       *     | zone1 | zone2 | zone3 |
       *     +-------+-------+-------+
       *     |  P P  |  P P  |   P   |
       *     +-------+-------+-------+
       *     - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
       *     scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
       *     violate MaxSkew(1).
       *     - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       *     When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
       *     to topologies that satisfy it.
       *     It's a required field. Default value is 1 and 0 is not allowed. */
      maxSkew?: number;
      /** @description MinDomains indicates a minimum number of eligible domains.
       *     When the number of eligible domains with matching topology keys is less than minDomains,
       *     Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
       *     And when the number of eligible domains with matching topology keys equals or greater than minDomains,
       *     this value has no effect on scheduling.
       *     As a result, when the number of eligible domains is less than minDomains,
       *     scheduler won't schedule more than maxSkew Pods to those domains.
       *     If value is nil, the constraint behaves as if MinDomains is equal to 1.
       *     Valid values are integers greater than 0.
       *     When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
       *
       *     For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
       *     labelSelector spread as 2/2/2:
       *     +-------+-------+-------+
       *     | zone1 | zone2 | zone3 |
       *     +-------+-------+-------+
       *     |  P P  |  P P  |  P P  |
       *     +-------+-------+-------+
       *     The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
       *     In this situation, new pod with the same labelSelector cannot be scheduled,
       *     because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
       *     it will violate MaxSkew.
       *     +optional */
      minDomains?: number;
      /** @description NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
       *     when calculating pod topology spread skew. Options are:
       *     - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
       *     - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
       *
       *     If this value is nil, the behavior is equivalent to the Honor policy.
       *     This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
       *     +optional */
      nodeAffinityPolicy?: components["schemas"]["v1.NodeInclusionPolicy"];
      /** @description NodeTaintsPolicy indicates how we will treat node taints when calculating
       *     pod topology spread skew. Options are:
       *     - Honor: nodes without taints, along with tainted nodes for which the incoming pod
       *     has a toleration, are included.
       *     - Ignore: node taints are ignored. All nodes are included.
       *
       *     If this value is nil, the behavior is equivalent to the Ignore policy.
       *     This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
       *     +optional */
      nodeTaintsPolicy?: components["schemas"]["v1.NodeInclusionPolicy"];
      /** @description TopologyKey is the key of node labels. Nodes that have a label with this key
       *     and identical values are considered to be in the same topology.
       *     We consider each <key, value> as a "bucket", and try to put balanced number
       *     of pods into each bucket.
       *     We define a domain as a particular instance of a topology.
       *     Also, we define an eligible domain as a domain whose nodes meet the requirements of
       *     nodeAffinityPolicy and nodeTaintsPolicy.
       *     e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
       *     And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
       *     It's a required field. */
      topologyKey?: string;
      /** @description WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
       *     the spread constraint.
       *     - DoNotSchedule (default) tells the scheduler not to schedule it.
       *     - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *       but giving higher precedence to topologies that would help reduce the
       *       skew.
       *     A constraint is considered "Unsatisfiable" for an incoming pod
       *     if and only if every possible node assignment for that pod would violate
       *     "MaxSkew" on some topology.
       *     For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
       *     labelSelector spread as 3/1/1:
       *     +-------+-------+-------+
       *     | zone1 | zone2 | zone3 |
       *     +-------+-------+-------+
       *     | P P P |   P   |   P   |
       *     +-------+-------+-------+
       *     If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
       *     to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
       *     MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
       *     won't make it *more* imbalanced.
       *     It's a required field. */
      whenUnsatisfiable?: components["schemas"]["v1.UnsatisfiableConstraintAction"];
    };
    "v1.TypedLocalObjectReference": {
      /** @description APIGroup is the group for the resource being referenced.
       *     If APIGroup is not specified, the specified Kind must be in the core API group.
       *     For any other third-party types, APIGroup is required.
       *     +optional */
      apiGroup?: string;
      /** @description Kind is the type of resource being referenced */
      kind?: string;
      /** @description Name is the name of resource being referenced */
      name?: string;
    };
    "v1.TypedObjectReference": {
      /** @description APIGroup is the group for the resource being referenced.
       *     If APIGroup is not specified, the specified Kind must be in the core API group.
       *     For any other third-party types, APIGroup is required.
       *     +optional */
      apiGroup?: string;
      /** @description Kind is the type of resource being referenced */
      kind?: string;
      /** @description Name is the name of resource being referenced */
      name?: string;
      /** @description Namespace is the namespace of resource being referenced
       *     Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
       *     (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
       *     +featureGate=CrossNamespaceVolumeDataSource
       *     +optional */
      namespace?: string;
    };
    /** @enum {string} */
    "v1.URIScheme": "HTTP" | "HTTPS";
    /** @enum {string} */
    "v1.UnsatisfiableConstraintAction": "DoNotSchedule" | "ScheduleAnyway";
    "v1.Volume": {
      /** @description awsElasticBlockStore represents an AWS Disk resource that is attached to a
       *     kubelet's host machine and then exposed to the pod.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
       *     +optional */
      awsElasticBlockStore?: components["schemas"]["v1.AWSElasticBlockStoreVolumeSource"];
      /** @description azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
       *     +optional */
      azureDisk?: components["schemas"]["v1.AzureDiskVolumeSource"];
      /** @description azureFile represents an Azure File Service mount on the host and bind mount to the pod.
       *     +optional */
      azureFile?: components["schemas"]["v1.AzureFileVolumeSource"];
      /** @description cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
       *     +optional */
      cephfs?: components["schemas"]["v1.CephFSVolumeSource"];
      /** @description cinder represents a cinder volume attached and mounted on kubelets host machine.
       *     More info: https://examples.k8s.io/mysql-cinder-pd/README.md
       *     +optional */
      cinder?: components["schemas"]["v1.CinderVolumeSource"];
      /** @description configMap represents a configMap that should populate this volume
       *     +optional */
      configMap?: components["schemas"]["v1.ConfigMapVolumeSource"];
      /** @description csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
       *     +optional */
      csi?: components["schemas"]["v1.CSIVolumeSource"];
      /** @description downwardAPI represents downward API about the pod that should populate this volume
       *     +optional */
      downwardAPI?: components["schemas"]["v1.DownwardAPIVolumeSource"];
      /** @description emptyDir represents a temporary directory that shares a pod's lifetime.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       *     +optional */
      emptyDir?: components["schemas"]["v1.EmptyDirVolumeSource"];
      /** @description ephemeral represents a volume that is handled by a cluster storage driver.
       *     The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
       *     and deleted when the pod is removed.
       *
       *     Use this if:
       *     a) the volume is only needed while the pod runs,
       *     b) features of normal volumes like restoring from snapshot or capacity
       *        tracking are needed,
       *     c) the storage driver is specified through a storage class, and
       *     d) the storage driver supports dynamic volume provisioning through
       *        a PersistentVolumeClaim (see EphemeralVolumeSource for more
       *        information on the connection between this volume type
       *        and PersistentVolumeClaim).
       *
       *     Use PersistentVolumeClaim or one of the vendor-specific
       *     APIs for volumes that persist for longer than the lifecycle
       *     of an individual pod.
       *
       *     Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
       *     be used that way - see the documentation of the driver for
       *     more information.
       *
       *     A pod can use both types of ephemeral volumes and
       *     persistent volumes at the same time.
       *
       *     +optional */
      ephemeral?: components["schemas"]["v1.EphemeralVolumeSource"];
      /** @description fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
       *     +optional */
      fc?: components["schemas"]["v1.FCVolumeSource"];
      /** @description flexVolume represents a generic volume resource that is
       *     provisioned/attached using an exec based plugin.
       *     +optional */
      flexVolume?: components["schemas"]["v1.FlexVolumeSource"];
      /** @description flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
       *     +optional */
      flocker?: components["schemas"]["v1.FlockerVolumeSource"];
      /** @description gcePersistentDisk represents a GCE Disk resource that is attached to a
       *     kubelet's host machine and then exposed to the pod.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
       *     +optional */
      gcePersistentDisk?: components["schemas"]["v1.GCEPersistentDiskVolumeSource"];
      /** @description gitRepo represents a git repository at a particular revision.
       *     DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
       *     EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
       *     into the Pod's container.
       *     +optional */
      gitRepo?: components["schemas"]["v1.GitRepoVolumeSource"];
      /** @description glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
       *     More info: https://examples.k8s.io/volumes/glusterfs/README.md
       *     +optional */
      glusterfs?: components["schemas"]["v1.GlusterfsVolumeSource"];
      /** @description hostPath represents a pre-existing file or directory on the host
       *     machine that is directly exposed to the container. This is generally
       *     used for system agents or other privileged things that are allowed
       *     to see the host machine. Most containers will NOT need this.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
       *     ---
       *     TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
       *     mount host directories as read/write.
       *     +optional */
      hostPath?: components["schemas"]["v1.HostPathVolumeSource"];
      /** @description iscsi represents an ISCSI Disk resource that is attached to a
       *     kubelet's host machine and then exposed to the pod.
       *     More info: https://examples.k8s.io/volumes/iscsi/README.md
       *     +optional */
      iscsi?: components["schemas"]["v1.ISCSIVolumeSource"];
      /** @description name of the volume.
       *     Must be a DNS_LABEL and unique within the pod.
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names */
      name?: string;
      /** @description nfs represents an NFS mount on the host that shares a pod's lifetime
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
       *     +optional */
      nfs?: components["schemas"]["v1.NFSVolumeSource"];
      /** @description persistentVolumeClaimVolumeSource represents a reference to a
       *     PersistentVolumeClaim in the same namespace.
       *     More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
       *     +optional */
      persistentVolumeClaim?: components["schemas"]["v1.PersistentVolumeClaimVolumeSource"];
      /** @description photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine */
      photonPersistentDisk?: components["schemas"]["v1.PhotonPersistentDiskVolumeSource"];
      /** @description portworxVolume represents a portworx volume attached and mounted on kubelets host machine
       *     +optional */
      portworxVolume?: components["schemas"]["v1.PortworxVolumeSource"];
      /** @description projected items for all in one resources secrets, configmaps, and downward API */
      projected?: components["schemas"]["v1.ProjectedVolumeSource"];
      /** @description quobyte represents a Quobyte mount on the host that shares a pod's lifetime
       *     +optional */
      quobyte?: components["schemas"]["v1.QuobyteVolumeSource"];
      /** @description rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
       *     More info: https://examples.k8s.io/volumes/rbd/README.md
       *     +optional */
      rbd?: components["schemas"]["v1.RBDVolumeSource"];
      /** @description scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
       *     +optional */
      scaleIO?: components["schemas"]["v1.ScaleIOVolumeSource"];
      /** @description secret represents a secret that should populate this volume.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
       *     +optional */
      secret?: components["schemas"]["v1.SecretVolumeSource"];
      /** @description storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
       *     +optional */
      storageos?: components["schemas"]["v1.StorageOSVolumeSource"];
      /** @description vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
       *     +optional */
      vsphereVolume?: components["schemas"]["v1.VsphereVirtualDiskVolumeSource"];
    };
    "v1.VolumeDevice": {
      /** @description devicePath is the path inside of the container that the device will be mapped to. */
      devicePath?: string;
      /** @description name must match the name of a persistentVolumeClaim in the pod */
      name?: string;
    };
    "v1.VolumeMount": {
      /** @description Path within the container at which the volume should be mounted.  Must
       *     not contain ':'. */
      mountPath?: string;
      /** @description mountPropagation determines how mounts are propagated from the host
       *     to container and the other way around.
       *     When not set, MountPropagationNone is used.
       *     This field is beta in 1.10.
       *     When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
       *     (which defaults to None).
       *     +optional */
      mountPropagation?: components["schemas"]["v1.MountPropagationMode"];
      /** @description This must match the Name of a Volume. */
      name?: string;
      /** @description Mounted read-only if true, read-write otherwise (false or unspecified).
       *     Defaults to false.
       *     +optional */
      readOnly?: boolean;
      /** @description RecursiveReadOnly specifies whether read-only mounts should be handled
       *     recursively.
       *
       *     If ReadOnly is false, this field has no meaning and must be unspecified.
       *
       *     If ReadOnly is true, and this field is set to Disabled, the mount is not made
       *     recursively read-only.  If this field is set to IfPossible, the mount is made
       *     recursively read-only, if it is supported by the container runtime.  If this
       *     field is set to Enabled, the mount is made recursively read-only if it is
       *     supported by the container runtime, otherwise the pod will not be started and
       *     an error will be generated to indicate the reason.
       *
       *     If this field is set to IfPossible or Enabled, MountPropagation must be set to
       *     None (or be unspecified, which defaults to None).
       *
       *     If this field is not specified, it is treated as an equivalent of Disabled.
       *
       *     +featureGate=RecursiveReadOnlyMounts
       *     +optional */
      recursiveReadOnly?: components["schemas"]["v1.RecursiveReadOnlyMode"];
      /** @description Path within the volume from which the container's volume should be mounted.
       *     Defaults to "" (volume's root).
       *     +optional */
      subPath?: string;
      /** @description Expanded path within the volume from which the container's volume should be mounted.
       *     Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
       *     Defaults to "" (volume's root).
       *     SubPathExpr and SubPath are mutually exclusive.
       *     +optional */
      subPathExpr?: string;
    };
    "v1.VolumeProjection": {
      /** @description ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
       *     of ClusterTrustBundle objects in an auto-updating file.
       *
       *     Alpha, gated by the ClusterTrustBundleProjection feature gate.
       *
       *     ClusterTrustBundle objects can either be selected by name, or by the
       *     combination of signer name and a label selector.
       *
       *     Kubelet performs aggressive normalization of the PEM contents written
       *     into the pod filesystem.  Esoteric PEM features such as inter-block
       *     comments and block headers are stripped.  Certificates are deduplicated.
       *     The ordering of certificates within the file is arbitrary, and Kubelet
       *     may change the order over time.
       *
       *     +featureGate=ClusterTrustBundleProjection
       *     +optional */
      clusterTrustBundle?: components["schemas"]["v1.ClusterTrustBundleProjection"];
      /** @description configMap information about the configMap data to project
       *     +optional */
      configMap?: components["schemas"]["v1.ConfigMapProjection"];
      /** @description downwardAPI information about the downwardAPI data to project
       *     +optional */
      downwardAPI?: components["schemas"]["v1.DownwardAPIProjection"];
      /** @description secret information about the secret data to project
       *     +optional */
      secret?: components["schemas"]["v1.SecretProjection"];
      /** @description serviceAccountToken is information about the serviceAccountToken data to project
       *     +optional */
      serviceAccountToken?: components["schemas"]["v1.ServiceAccountTokenProjection"];
    };
    "v1.VolumeResourceRequirements": {
      /** @description Limits describes the maximum amount of compute resources allowed.
       *     More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       *     +optional */
      limits?: components["schemas"]["v1.ResourceList"];
      /** @description Requests describes the minimum amount of compute resources required.
       *     If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       *     otherwise to an implementation-defined value. Requests cannot exceed Limits.
       *     More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       *     +optional */
      requests?: components["schemas"]["v1.ResourceList"];
    };
    "v1.VsphereVirtualDiskVolumeSource": {
      /** @description fsType is filesystem type to mount.
       *     Must be a filesystem type supported by the host operating system.
       *     Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
       *     +optional */
      fsType?: string;
      /** @description storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
       *     +optional */
      storagePolicyID?: string;
      /** @description storagePolicyName is the storage Policy Based Management (SPBM) profile name.
       *     +optional */
      storagePolicyName?: string;
      /** @description volumePath is the path that identifies vSphere volume vmdk */
      volumePath?: string;
    };
    "v1.WeightedPodAffinityTerm": {
      /** @description Required. A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm?: components["schemas"]["v1.PodAffinityTerm"];
      /** @description weight associated with matching the corresponding podAffinityTerm,
       *     in the range 1-100. */
      weight?: number;
    };
    "v1.WhenExpression": {
      /** @description CEL is a string of Common Language Expression, which can be used to conditionally execute
       *     the task based on the result of the expression evaluation
       *     More info about CEL syntax: https://github.com/google/cel-spec/blob/master/doc/langdef.md
       *     +optional */
      cel?: string;
      /** @description Input is the string for guard checking which can be a static input or an output from a parent Task */
      input?: string;
      /** @description Operator that represents an Input's relationship to the values */
      operator?: components["schemas"]["selection.Operator"];
      /** @description Values is an array of strings, which is compared against the input, for guard checking
       *     It must be non-empty
       *     +listType=atomic */
      values?: string[];
    };
    "v1.WindowsSecurityContextOptions": {
      /** @description GMSACredentialSpec is where the GMSA admission webhook
       *     (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
       *     GMSA credential spec named by the GMSACredentialSpecName field.
       *     +optional */
      gmsaCredentialSpec?: string;
      /** @description GMSACredentialSpecName is the name of the GMSA credential spec to use.
       *     +optional */
      gmsaCredentialSpecName?: string;
      /** @description HostProcess determines if a container should be run as a 'Host Process' container.
       *     All of a Pod's containers must have the same effective HostProcess value
       *     (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
       *     In addition, if HostProcess is true then HostNetwork must also be set to true.
       *     +optional */
      hostProcess?: boolean;
      /** @description The UserName in Windows to run the entrypoint of the container process.
       *     Defaults to the user specified in image metadata if unspecified.
       *     May also be set in PodSecurityContext. If set in both SecurityContext and
       *     PodSecurityContext, the value specified in SecurityContext takes precedence.
       *     +optional */
      runAsUserName?: string;
    };
    "v1.WorkspaceBinding": {
      /** @description ConfigMap represents a configMap that should populate this workspace.
       *     +optional */
      configMap?: components["schemas"]["v1.ConfigMapVolumeSource"];
      /** @description CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
       *     +optional */
      csi?: components["schemas"]["v1.CSIVolumeSource"];
      /** @description EmptyDir represents a temporary directory that shares a Task's lifetime.
       *     More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       *     Either this OR PersistentVolumeClaim can be used.
       *     +optional */
      emptyDir?: components["schemas"]["v1.EmptyDirVolumeSource"];
      /** @description Name is the name of the workspace populated by the volume. */
      name?: string;
      /** @description PersistentVolumeClaimVolumeSource represents a reference to a
       *     PersistentVolumeClaim in the same namespace. Either this OR EmptyDir can be used.
       *     +optional */
      persistentVolumeClaim?: components["schemas"]["v1.PersistentVolumeClaimVolumeSource"];
      /** @description Projected represents a projected volume that should populate this workspace.
       *     +optional */
      projected?: components["schemas"]["v1.ProjectedVolumeSource"];
      /** @description Secret represents a secret that should populate this workspace.
       *     +optional */
      secret?: components["schemas"]["v1.SecretVolumeSource"];
      /** @description SubPath is optionally a directory on the volume which should be used
       *     for this binding (i.e. the volume will be mounted at this sub directory).
       *     +optional */
      subPath?: string;
      /** @description VolumeClaimTemplate is a template for a claim that will be created in the same namespace.
       *     The PipelineRun controller is responsible for creating a unique claim for each instance of PipelineRun.
       *     +optional */
      volumeClaimTemplate?: components["schemas"]["v1.PersistentVolumeClaim"];
    };
    "v1.WorkspaceDeclaration": {
      /** @description Description is an optional human readable description of this volume.
       *     +optional */
      description?: string;
      /** @description MountPath overrides the directory that the volume will be made available at.
       *     +optional */
      mountPath?: string;
      /** @description Name is the name by which you can bind the volume at runtime. */
      name?: string;
      /** @description Optional marks a Workspace as not being required in TaskRuns. By default
       *     this field is false and so declared workspaces are required. */
      optional?: boolean;
      /** @description ReadOnly dictates whether a mounted volume is writable. By default this
       *     field is false and so mounted volumes are writable. */
      readOnly?: boolean;
    };
    "v1.WorkspacePipelineTaskBinding": {
      /** @description Name is the name of the workspace as declared by the task */
      name?: string;
      /** @description SubPath is optionally a directory on the volume which should be used
       *     for this binding (i.e. the volume will be mounted at this sub directory).
       *     +optional */
      subPath?: string;
      /** @description Workspace is the name of the workspace declared by the pipeline
       *     +optional */
      workspace?: string;
    };
    "v1.WorkspaceUsage": {
      /** @description MountPath is the path that the workspace should be mounted to inside the Step or Sidecar,
       *     overriding any MountPath specified in the Task's WorkspaceDeclaration. */
      mountPath?: string;
      /** @description Name is the name of the workspace this Step or Sidecar wants access to. */
      name?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
